41594db4174e9a2054cd5a4c93e97f16
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get completeChallenge () {
        return completeChallenge;
    },
    get createUser () {
        return createUser;
    },
    get deleteUser () {
        return deleteUser;
    },
    get editUserProfile () {
        return editUserProfile;
    },
    get getLocation () {
        return getLocation;
    },
    get getUserAdventures () {
        return getUserAdventures;
    },
    get getUserAvatar () {
        return getUserAvatar;
    },
    get getUserById () {
        return getUserById;
    },
    get getUserCoins () {
        return getUserCoins;
    },
    get getUserInterests () {
        return getUserInterests;
    },
    get getUserPurchasedItems () {
        return getUserPurchasedItems;
    },
    get getUserRank () {
        return getUserRank;
    },
    get getUserStars () {
        return getUserStars;
    },
    get getUsers () {
        return getUsers;
    },
    get startAdventure () {
        return startAdventure;
    },
    get updateLocation () {
        return updateLocation;
    },
    get updatePassword () {
        return updatePassword;
    },
    get updateUserCoins () {
        return updateUserCoins;
    },
    get updateUserStars () {
        return updateUserStars;
    }
});
const _bcrypt = /*#__PURE__*/ _interop_require_default(require("bcrypt"));
const _usermodel = require("../models/user.model");
const _error = require("../utils/error");
const _checkId = require("../utils/checkId");
const _adventuremodel = require("../models/adventure.model");
const _familymodel = require("../models/family.model");
const _recalculateFamilyMemberRanks = require("../utils/recalculateFamilyMemberRanks");
const _emailservice = require("../services/email.service");
const _generateSecurePassword = require("../utils/generateSecurePassword");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const getUsers = async (req, res)=>{
    try {
        const users = await _usermodel.User.find();
        res.status(200).send(users);
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving users",
            res,
            status: 500
        });
    }
};
const getUserById = async (req, res)=>{
    try {
        const { userId } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        const targetUserId = userId || req.user._id;
        if (!(0, _checkId.checkId)({
            id: targetUserId,
            res
        })) return;
        let projection = '_id name email birthday role avatar gender stars coins interests nbOfTasksCompleted rankInFamily memberSince familyId dailyMessage isTempPassword'; // Basic user info
        // Fetch the user with specific fields
        const user = await _usermodel.User.findById(targetUserId).select(projection);
        // If user not found, return 404
        if (!user) {
            return (0, _error.throwError)({
                message: "User not found",
                res,
                status: 404
            });
        }
        if (req.user._id.toString() !== targetUserId.toString() && [
            'parent',
            'child'
        ].includes(req.user.role) && req.user.email != user.email) {
            return (0, _error.throwError)({
                message: "Forbidden",
                res,
                status: 403
            });
        }
        res.status(200).json({
            message: "Retrieving user successfully",
            user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user",
            res,
            status: 500
        });
    }
};
const createUser = async (req, res)=>{
    try {
        const data = req.body;
        const { name, birthday, gender, role, avatar, interests } = data;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        if (req.user.role === "child") {
            return (0, _error.throwError)({
                message: "Forbidden",
                res,
                status: 403
            });
        }
        // verify all fields are filled
        if (!name || !birthday || !gender || !role || !avatar || !interests) {
            return (0, _error.throwError)({
                message: "All required fields must be filled.",
                res,
                status: 400
            });
        }
        const email = req.user.email;
        const existingUser = await _usermodel.User.findOne({
            name: name,
            email: email
        });
        if (existingUser) {
            return (0, _error.throwError)({
                message: "This username is already taken for this email.",
                res,
                status: 409
            });
        }
        if (!Array.isArray(interests)) {
            return (0, _error.throwError)({
                message: "Interests must be an array.",
                res,
                status: 400
            });
        }
        // Gender Validation
        const validGenders = [
            'male',
            'female'
        ];
        if (!validGenders.includes(gender)) {
            return (0, _error.throwError)({
                message: "Gender must be either 'male' or 'female'.",
                res,
                status: 400
            });
        }
        // Role validation
        const validRoles = [
            'owner',
            'parent',
            'child',
            'admin'
        ];
        if (!validRoles.includes(role)) {
            return (0, _error.throwError)({
                message: "Invalid role.",
                res,
                status: 400
            });
        }
        // Birthday Validation
        if (isNaN(new Date(birthday).getTime())) {
            return (0, _error.throwError)({
                message: "Invalid birthday format.",
                res,
                status: 400
            });
        }
        const generatedPassword = (0, _generateSecurePassword.generateSecurePassword)();
        const hashedPassword = await _bcrypt.default.hash(generatedPassword, 12);
        // Find the parent's family
        const family = await _familymodel.Family.findOne({
            email: req.user.email
        });
        if (!family) {
            return (0, _error.throwError)({
                message: "Family not found.",
                res,
                status: 404
            });
        }
        // Create the user with the parent's familyId
        const user = await _usermodel.User.create({
            ...data,
            email: email,
            password: hashedPassword,
            familyId: family._id // Link to parent's family
        });
        // Add the new user to the family's members list
        if (!family.members.includes(user.id)) {
            family.members.push({
                _id: user.id,
                role,
                name,
                gender,
                avatar
            });
            await family.save();
        }
        // Recalculate the ranks after adding the new user
        await (0, _recalculateFamilyMemberRanks.recalculateFamilyMemberRanks)(family._id, user);
        const from = `"Guardian Grove" <${process.env.EMAIL_USERNAME}>`;
        const to = email;
        const subject = `Welcome to Guardian Grove - ${name}'s Account Details`;
        const html = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; color: #333;">
                <div style="background-color: #f8f9fa; padding: 20px; border-radius: 5px;">
                    <h2 style="color: #2c3e50;">Welcome to Guardian Grove!</h2>
                    <p>Hello ${req.user.name},</p>
                    
                    <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #3498db;">
                        <p>You've successfully created a <strong>${role}</strong> account for <strong>${name}</strong>.</p>
                        <p>Here are the login details:</p>
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #ddd; width: 120px;"><strong>Username:</strong></td>
                                <td style="padding: 8px; border-bottom: 1px solid #ddd;">${name}</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><strong>Temporary Password:</strong></td>
                                <td style="padding: 8px;">${generatedPassword}</td>
                            </tr>
                        </table>
                    </div>
                    
                    <p style="color: #e74c3c; font-weight: bold;">Please change this password after first login.</p>
                    
                    <p>If you didn't request this account creation, please contact our support immediately.</p>
                    
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
                        <p>Best regards,</p>
                        <p><strong>The Guardian Grove Team</strong></p>
                        <p style="font-size: 12px; color: #7f8c8d;">This is an automated message - please do not reply directly to this email.</p>
                    </div>
                </div>
            </div>
        `;
        // Send email with the temporary password
        await (0, _emailservice.sendMail)(from, to, subject, html);
        await user.save();
        res.status(200).send({
            message: "User created successfully, password email sent.",
            user
        });
    } catch (error) {
        if (error instanceof Error) {
            // Handle MongoDB duplicate key error (11000)
            if (error.code === 11000) {
                return (0, _error.throwError)({
                    message: "A user with this name and email already exists.",
                    res,
                    status: 409
                });
            } else {
                return (0, _error.throwError)({
                    message: error.message,
                    res,
                    status: 500
                });
            }
        } else {
            return (0, _error.throwError)({
                message: "An unknown error occurred.",
                res,
                status: 500
            });
        }
    }
};
const editUserProfile = async (req, res)=>{
    try {
        const { userId, name, birthday, gender, avatar, role } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        if (role && ![
            'parent',
            'admin',
            'owner'
        ].includes(req.user.role)) {
            return (0, _error.throwError)({
                message: "Forbidden: You cannot change role nor email",
                res,
                status: 403
            });
        }
        let user;
        if (userId) {
            if (!(0, _checkId.checkId)({
                id: userId,
                res
            })) return;
            if (req.user._id.toString() !== userId && ![
                'parent',
                'admin',
                'owner'
            ].includes(req.user.role)) {
                return (0, _error.throwError)({
                    message: "Forbidden",
                    res,
                    status: 403
                });
            }
            user = await _usermodel.User.findById(userId);
            if (!user) {
                return (0, _error.throwError)({
                    message: "User not found",
                    res,
                    status: 404
                });
            }
            if (req.user.role !== "admin" && req.user.email !== user.email) {
                return (0, _error.throwError)({
                    message: "Forbidden",
                    res,
                    status: 403
                });
            }
        } else {
            user = req.user;
        }
        // Check if a user with the same email and name exists
        if (name) {
            const existingUser = await _usermodel.User.findOne({
                email: user.email,
                name,
                _id: {
                    $ne: user._id
                }
            });
            if (existingUser) {
                return (0, _error.throwError)({
                    message: "A user with the same email and name already exists.",
                    res,
                    status: 400
                });
            }
            user.name = name;
        }
        if (name) user.name = name;
        if (birthday) user.birthday = birthday;
        if (gender) user.gender = gender;
        if (avatar) user.avatar = avatar;
        if (role) user.role = role;
        await user.save();
        res.status(200).send({
            message: "User profile updated successfully",
            user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Failed to update. An unknown error occurred.",
            res,
            status: 500
        });
    }
};
const deleteUser = async (req, res)=>{
    try {
        const { userId } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        let user;
        if (userId) {
            if (!(0, _checkId.checkId)({
                id: userId,
                res
            })) return;
            if (req.user._id.toString() !== userId && ![
                'parent',
                'admin',
                'owner'
            ].includes(req.user.role)) {
                return (0, _error.throwError)({
                    message: "Forbidden",
                    res,
                    status: 403
                });
            }
            user = await _usermodel.User.findById(userId);
            if (!user) {
                return (0, _error.throwError)({
                    message: "User not found",
                    res,
                    status: 404
                });
            }
            if (req.user.role !== "admin" && req.user.email !== user.email) {
                return (0, _error.throwError)({
                    message: "Forbidden",
                    res,
                    status: 403
                });
            }
        } else {
            user = req.user;
        }
        // Prevent deleting the last parent in a family
        const family = await _familymodel.Family.findById(user.familyId);
        if (family) {
            const parentsCount = await _usermodel.User.countDocuments({
                familyId: family._id,
                role: 'parent'
            });
            if (user.role === 'parent' && parentsCount <= 1) {
                return (0, _error.throwError)({
                    message: "Cannot delete the last parent in the family",
                    res,
                    status: 400
                });
            }
            // Remove user from the family members list
            family.members = family.members.filter((member)=>member._id.toString() !== user._id.toString());
            await family.save();
        }
        // Delete the user
        await _usermodel.User.findByIdAndDelete(user._id);
        res.status(200).send({
            message: "User deleted successfully",
            user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Failed to delete. An unknown error occurred.",
            res,
            status: 500
        });
    }
};
const updatePassword = async (req, res)=>{
    try {
        const { userId, oldPassword, newPassword, confirmPassword } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        let user;
        if (userId) {
            if (!(0, _checkId.checkId)({
                id: userId,
                res
            })) return;
            if (req.user._id.toString() !== userId && req.user.role !== "admin") {
                return (0, _error.throwError)({
                    message: "Forbidden",
                    res,
                    status: 403
                });
            }
            user = await _usermodel.User.findById(userId);
            if (!user) {
                return (0, _error.throwError)({
                    message: "User not found",
                    res,
                    status: 404
                });
            }
        } else {
            user = req.user;
        }
        // Validate required fields
        if (!oldPassword || !newPassword || !confirmPassword) {
            return (0, _error.throwError)({
                message: "All fields are required.",
                res,
                status: 400
            });
        }
        if (newPassword !== confirmPassword) {
            return (0, _error.throwError)({
                message: "Passwords do not match.",
                res,
                status: 400
            });
        }
        // Verify old password
        const isMatch = await _bcrypt.default.compare(oldPassword, user.password);
        if (!isMatch) {
            return (0, _error.throwError)({
                message: "Old password is incorrect.",
                res,
                status: 400
            });
        }
        // Check if the new password is different from the old one
        const isSamePassword = await _bcrypt.default.compare(newPassword, req.user.password);
        if (isSamePassword) {
            return (0, _error.throwError)({
                message: "New password cannot be the same as the old password.",
                res,
                status: 400
            });
        }
        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
        if (!passwordRegex.test(newPassword)) {
            return (0, _error.throwError)({
                message: "Password must be at least 8 characters long, include an uppercase letter, lowercase letter, a number, and a special character.",
                res,
                status: 400
            });
        }
        // Hash new password
        const hashedPassword = await _bcrypt.default.hash(newPassword, 10);
        user.password = hashedPassword;
        user.isTempPassword = false;
        await user.save();
        // Return success response
        res.status(200).send({
            message: "Password updated successfully.",
            password: newPassword
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Failed to update password.",
            res,
            status: 500
        });
    }
};
const getUserStars = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "Stars retrieved successfully",
            stars: req.user.stars
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user stars",
            res,
            status: 500
        });
    }
};
const updateUserStars = async (req, res)=>{
    try {
        const { stars } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        if (stars === undefined || typeof stars !== "number" || stars < 0) {
            return (0, _error.throwError)({
                message: "Stars must be a valid number.",
                res,
                status: 400
            });
        }
        req.user.stars += stars;
        await req.user.save();
        if (!req.user.familyId) {
            return (0, _error.throwError)({
                message: "No family id",
                res,
                status: 400
            });
        }
        await _familymodel.Family.findByIdAndUpdate(req.user.familyId, {
            $inc: {
                totalStars: stars
            }
        });
        await (0, _recalculateFamilyMemberRanks.recalculateFamilyMemberRanks)(req.user.familyId, req.user);
        res.status(200).send({
            message: "User stars updated successfully",
            user: req.user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error updating user stars",
            res,
            status: 500
        });
    }
};
const getUserCoins = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "Coins retrieved successfully",
            coins: req.user.coins
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user coins",
            res,
            status: 500
        });
    }
};
const updateUserCoins = async (req, res)=>{
    try {
        const { coins } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        if (coins === undefined || typeof coins !== "number") {
            return (0, _error.throwError)({
                message: "Stars must be a valid number.",
                res,
                status: 400
            });
        }
        req.user.coins += coins;
        await req.user.save();
        res.status(200).send({
            message: "User coins updated successfully",
            user: req.user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error updating user coins",
            res,
            status: 500
        });
    }
};
const getLocation = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "Location retrieved successfully",
            location: req.user.currentLocation
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user location",
            res,
            status: 500
        });
    }
};
const updateLocation = async (req, res)=>{
    try {
        const { currentLocation } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        if (typeof currentLocation !== "string" || currentLocation.trim() === "") {
            return (0, _error.throwError)({
                message: "Location must be valid.",
                res,
                status: 400
            });
        }
        req.user.currentLocation = currentLocation;
        await req.user.save();
        res.status(200).send({
            message: "User location updated successfully",
            user: req.user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error updating user location",
            res,
            status: 500
        });
    }
};
const getUserRank = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "Rank retrieved successfully",
            Rank: req.user.rankInFamily
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user rank",
            res,
            status: 500
        });
    }
};
const getUserInterests = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "Interests retrieved successfully",
            Interests: req.user.interests
        });
    } catch (error) {
        (0, _error.throwError)({
            message: "Error retrieving user interests",
            res,
            status: 500
        });
    }
};
const startAdventure = async (req, res)=>{
    try {
        const { adventureId } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        const userId = req.user._id;
        if (!(0, _checkId.checkId)({
            id: adventureId,
            res
        })) return;
        if (!(0, _checkId.checkId)({
            id: userId.toString(),
            res
        })) return;
        // Find the adventure by adventureId
        const adventure = await _adventuremodel.Adventure.findById(adventureId);
        if (!adventure) {
            return (0, _error.throwError)({
                message: "Adventure not found",
                res,
                status: 404
            });
        }
        const existingAdventureProgress = req.user.adventures.find((adventureProgress)=>adventureProgress.adventureId.equals(adventureId));
        if (existingAdventureProgress) {
            return (0, _error.throwError)({
                message: "Adventure already started",
                res,
                status: 400
            });
        }
        // Add adventure to user's adventures
        const newAdventureProgress = {
            adventureId: adventureId,
            challenges: adventure.challenges.map((challenge)=>({
                    challengeId: challenge._id,
                    isCompleted: false
                })),
            status: "in-progress",
            isAdventureCompleted: false,
            starsReward: adventure.starsReward,
            coinsReward: adventure.coinsReward,
            progress: 0
        };
        req.user.adventures.push(newAdventureProgress);
        await req.user.save();
        res.status(200).send({
            message: "Adventure started successfully",
            user: req.user
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "An unknown error occurred while starting the adventure.",
            res,
            status: 500
        });
    }
};
const completeChallenge = async (req, res)=>{
    try {
        const { adventureId, challengeId } = req.body;
        if (!(0, _checkId.checkId)({
            id: adventureId,
            res
        })) return;
        if (!(0, _checkId.checkId)({
            id: challengeId,
            res
        })) return;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        const user = req.user;
        const adventureProgress = user.adventures.find((adventure)=>adventure.adventureId.equals(adventureId));
        if (!adventureProgress) {
            return (0, _error.throwError)({
                message: "Adventure not found in user's profile",
                res,
                status: 404
            });
        }
        const challenge = adventureProgress.challenges.find((challenge)=>challenge.challengeId.equals(challengeId));
        if (!challenge) {
            return (0, _error.throwError)({
                message: "Challenge not found in adventure",
                res,
                status: 404
            });
        }
        // Fetch the full adventure to get challenge rewards
        const adventure = await _adventuremodel.Adventure.findById(adventureId).lean();
        if (!adventure) {
            return (0, _error.throwError)({
                message: "Adventure not found",
                res,
                status: 404
            });
        }
        const targetChallenge = adventure.challenges.find((ch)=>ch._id.equals(challengeId));
        if (!targetChallenge) {
            return (0, _error.throwError)({
                message: "Challenge data not found in adventure",
                res,
                status: 404
            });
        }
        // Mark challenge as complete and add rewards
        challenge.isCompleted = true;
        challenge.completedAt = new Date();
        const starsReward = targetChallenge.starsReward;
        const coinsReward = targetChallenge.coinsReward;
        user.stars += starsReward;
        user.coins += coinsReward;
        adventureProgress.progress = adventureProgress.challenges.filter((challenge)=>challenge.isCompleted).length / adventureProgress.challenges.length * 100;
        let adventureStars = 0;
        if (adventureProgress.progress === 100) {
            adventureProgress.isAdventureCompleted = true;
            adventureProgress.status = 'completed';
            adventureStars = adventureProgress.starsReward;
            user.coins += adventureProgress.coinsReward;
            user.stars += adventureStars;
        }
        // Update the family total stars
        if (user.familyId) {
            const totalStars = starsReward + adventureStars;
            await _familymodel.Family.findByIdAndUpdate(user.familyId, {
                $inc: {
                    totalStars: totalStars
                }
            });
            await (0, _recalculateFamilyMemberRanks.recalculateFamilyMemberRanks)(user.familyId, user);
        }
        await user.save();
        res.status(200).json({
            message: "Challenge completed successfully",
            adventureProgress
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "An unknown error occurred while completing the challenge.",
            res,
            status: 500
        });
    }
};
const getUserAdventures = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        res.status(200).send({
            message: "User adventures retrieved successfully",
            Adventure: req.user.adventures
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving user adventures",
            res,
            status: 500
        });
    }
};
const getUserPurchasedItems = async (req, res)=>{
    try {
        const { userId } = req.body;
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        const targetUserId = userId || req.user._id;
        if (!(0, _checkId.checkId)({
            id: targetUserId,
            res
        })) return;
        const isAuthorized = req.user._id.toString() === targetUserId.toString();
        if (!isAuthorized) {
            return (0, _error.throwError)({
                message: "Forbidden",
                res,
                status: 403
            });
        }
        // Fetch only itemIds from purchasedItems
        const user = await _usermodel.User.findById(targetUserId).select('purchasedItems.itemId');
        if (!user) {
            return (0, _error.throwError)({
                message: "User not found",
                res,
                status: 404
            });
        }
        const purchasedItemIds = user.purchasedItems.map((item)=>item.itemId);
        res.status(200).json({
            message: "Purchased items retrieved successfully",
            purchasedItems: purchasedItemIds
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error retrieving purchased items",
            res,
            status: 500
        });
    }
};
const getUserAvatar = async (req, res)=>{
    try {
        if (!req.user) {
            return (0, _error.throwError)({
                message: "Unauthorized",
                res,
                status: 401
            });
        }
        const user = req.user;
        res.status(200).json({
            message: "Avatar retrieved successfully",
            avatar: user.avatar
        });
    } catch (error) {
        return (0, _error.throwError)({
            message: "Error fetching avatar",
            res,
            status: 500
        });
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNFUlxcRGVza3RvcFxcZ3VhcmRpYW4tZ3JvdmVcXGd1YXJkaWFuLWdyb3ZlLWJhY2tlbmRcXHNyY1xcY29udHJvbGxlcnNcXHVzZXIuY29udHJvbGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gJ2V4cHJlc3MnO1xyXG5pbXBvcnQgYmNyeXB0IGZyb20gXCJiY3J5cHRcIjtcclxuaW1wb3J0IHsgVXNlciB9IGZyb20gXCIuLi9tb2RlbHMvdXNlci5tb2RlbFwiO1xyXG5pbXBvcnQgeyB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3InO1xyXG5pbXBvcnQgeyBDdXN0b21SZXF1ZXN0IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jdXN0b21SZXF1ZXN0JztcclxuaW1wb3J0IHsgY2hlY2tJZCB9IGZyb20gJy4uL3V0aWxzL2NoZWNrSWQnO1xyXG5pbXBvcnQgeyBBZHZlbnR1cmUgfSBmcm9tICcuLi9tb2RlbHMvYWR2ZW50dXJlLm1vZGVsJztcclxuaW1wb3J0IHsgSUFkdmVudHVyZVByb2dyZXNzIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9JQWR2ZW50dXJlUHJvZ3Jlc3MnO1xyXG5pbXBvcnQgeyBGYW1pbHkgfSBmcm9tICcuLi9tb2RlbHMvZmFtaWx5Lm1vZGVsJztcclxuaW1wb3J0IHsgcmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcyB9IGZyb20gJy4uL3V0aWxzL3JlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MnO1xyXG5pbXBvcnQgbm9kZW1haWxlciBmcm9tIFwibm9kZW1haWxlclwiO1xyXG5pbXBvcnQgeyBzZW5kTWFpbCB9IGZyb20gJy4uL3NlcnZpY2VzL2VtYWlsLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVNlY3VyZVBhc3N3b3JkIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhdGVTZWN1cmVQYXNzd29yZCc7XHJcblxyXG4vLyBBUEkgdG8gZ2V0IGFsbCB1c2Vyc1xyXG5leHBvcnQgY29uc3QgZ2V0VXNlcnMgPSBhc3luYyhyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IFVzZXIuZmluZCgpO1xyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHVzZXJzKTtcclxuICAgIH1jYXRjaChlcnJvcil7XHJcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkVycm9yIHJldHJpZXZpbmcgdXNlcnNcIiwgcmVzLCBzdGF0dXM6IDUwMH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQVBJIHRvIGdldCBhIHVzZXIgYmFzZWQgb24gaGlzIElkXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyQnlJZCA9IGFzeW5jIChyZXE6IEN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCByZXEudXNlci5faWQ7XHJcblxyXG4gICAgICAgIGlmICghY2hlY2tJZCh7IGlkOiB0YXJnZXRVc2VySWQsIHJlcyB9KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcHJvamVjdGlvbiA9ICdfaWQgbmFtZSBlbWFpbCBiaXJ0aGRheSByb2xlIGF2YXRhciBnZW5kZXIgc3RhcnMgY29pbnMgaW50ZXJlc3RzIG5iT2ZUYXNrc0NvbXBsZXRlZCByYW5rSW5GYW1pbHkgbWVtYmVyU2luY2UgZmFtaWx5SWQgZGFpbHlNZXNzYWdlIGlzVGVtcFBhc3N3b3JkJzsgIC8vIEJhc2ljIHVzZXIgaW5mb1xyXG5cclxuICAgICAgICAvLyBGZXRjaCB0aGUgdXNlciB3aXRoIHNwZWNpZmljIGZpZWxkc1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRCeUlkKHRhcmdldFVzZXJJZCkuc2VsZWN0KHByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICAvLyBJZiB1c2VyIG5vdCBmb3VuZCwgcmV0dXJuIDQwNFxyXG4gICAgICAgIGlmICghdXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVXNlciBub3QgZm91bmRcIiwgcmVzLCBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXEudXNlci5faWQudG9TdHJpbmcoKSAhPT0gdGFyZ2V0VXNlcklkLnRvU3RyaW5nKCkgJiYgWydwYXJlbnQnLCAnY2hpbGQnXS5pbmNsdWRlcyhyZXEudXNlci5yb2xlKSAmJiByZXEudXNlci5lbWFpbCAhPSB1c2VyLmVtYWlsKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZvcmJpZGRlblwiLCByZXMsIHN0YXR1czogNDAzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLmpzb24oeyBtZXNzYWdlOiBcIlJldHJpZXZpbmcgdXNlciBzdWNjZXNzZnVsbHlcIiwgdXNlciB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkVycm9yIHJldHJpZXZpbmcgdXNlclwiLCByZXMsIHN0YXR1czogNTAwIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQVBJIHRvIGNyZWF0ZSB1c2VyXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVVc2VyID0gYXN5bmMgKHJlcTogQ3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBuYW1lLCBiaXJ0aGRheSwgZ2VuZGVyLCByb2xlLCBhdmF0YXIsIGludGVyZXN0cyB9ID0gZGF0YTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXEudXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZFwiLCByZXMsIHN0YXR1czogNDAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihyZXEudXNlci5yb2xlID09PSBcImNoaWxkXCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRm9yYmlkZGVuXCIsIHJlcywgc3RhdHVzOiA0MDMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2ZXJpZnkgYWxsIGZpZWxkcyBhcmUgZmlsbGVkXHJcbiAgICAgICAgaWYgKCFuYW1lIHx8ICFiaXJ0aGRheSB8fCAhZ2VuZGVyIHx8ICFyb2xlIHx8ICFhdmF0YXIgfHwgIWludGVyZXN0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiQWxsIHJlcXVpcmVkIGZpZWxkcyBtdXN0IGJlIGZpbGxlZC5cIiwgcmVzLCBzdGF0dXM6IDQwMH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZW1haWwgPSByZXEudXNlci5lbWFpbDtcclxuXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgVXNlci5maW5kT25lKHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgZW1haWw6IGVtYWlsICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVGhpcyB1c2VybmFtZSBpcyBhbHJlYWR5IHRha2VuIGZvciB0aGlzIGVtYWlsLlwiLCByZXMsIHN0YXR1czogNDA5fSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW50ZXJlc3RzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiSW50ZXJlc3RzIG11c3QgYmUgYW4gYXJyYXkuXCIsIHJlcywgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZW5kZXIgVmFsaWRhdGlvblxyXG4gICAgICAgIGNvbnN0IHZhbGlkR2VuZGVycyA9IFsnbWFsZScsICdmZW1hbGUnXTtcclxuICAgICAgICBpZiAoIXZhbGlkR2VuZGVycy5pbmNsdWRlcyhnZW5kZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJHZW5kZXIgbXVzdCBiZSBlaXRoZXIgJ21hbGUnIG9yICdmZW1hbGUnLlwiLCByZXMsIHN0YXR1czogNDAwfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb2xlIHZhbGlkYXRpb25cclxuICAgICAgICBjb25zdCB2YWxpZFJvbGVzID0gWydvd25lcicsICdwYXJlbnQnLCAnY2hpbGQnLCAnYWRtaW4nXTtcclxuICAgICAgICBpZiAoIXZhbGlkUm9sZXMuaW5jbHVkZXMocm9sZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkludmFsaWQgcm9sZS5cIiwgcmVzLCBzdGF0dXM6IDQwMH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQmlydGhkYXkgVmFsaWRhdGlvblxyXG4gICAgICAgIGlmIChpc05hTihuZXcgRGF0ZShiaXJ0aGRheSkuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiSW52YWxpZCBiaXJ0aGRheSBmb3JtYXQuXCIsIHJlcywgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBnZW5lcmF0ZWRQYXNzd29yZCA9IGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQoKTtcclxuICAgICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9IGF3YWl0IGJjcnlwdC5oYXNoKGdlbmVyYXRlZFBhc3N3b3JkLCAxMik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50J3MgZmFtaWx5XHJcbiAgICAgICAgY29uc3QgZmFtaWx5ID0gYXdhaXQgRmFtaWx5LmZpbmRPbmUoeyBlbWFpbDogcmVxLnVzZXIuZW1haWwgfSk7XHJcbiAgICAgICAgaWYgKCFmYW1pbHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZhbWlseSBub3QgZm91bmQuXCIsIHJlcywgc3RhdHVzOiA0MDQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHVzZXIgd2l0aCB0aGUgcGFyZW50J3MgZmFtaWx5SWRcclxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5jcmVhdGUoe1xyXG4gICAgICAgICAgICAuLi5kYXRhLFxyXG4gICAgICAgICAgICBlbWFpbDogZW1haWwsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBoYXNoZWRQYXNzd29yZCxcclxuICAgICAgICAgICAgZmFtaWx5SWQ6IGZhbWlseS5faWQgIC8vIExpbmsgdG8gcGFyZW50J3MgZmFtaWx5XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHVzZXIgdG8gdGhlIGZhbWlseSdzIG1lbWJlcnMgbGlzdFxyXG4gICAgICAgIGlmICghZmFtaWx5Lm1lbWJlcnMuaW5jbHVkZXModXNlci5pZCkpIHtcclxuICAgICAgICAgICAgZmFtaWx5Lm1lbWJlcnMucHVzaCh7X2lkOiB1c2VyLmlkLCByb2xlLCBuYW1lLCBnZW5kZXIsIGF2YXRhcn0pO1xyXG4gICAgICAgICAgICBhd2FpdCBmYW1pbHkuc2F2ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHJhbmtzIGFmdGVyIGFkZGluZyB0aGUgbmV3IHVzZXJcclxuICAgICAgICBhd2FpdCByZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzKGZhbWlseS5faWQsIHVzZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBmcm9tOiBzdHJpbmcgPSBgXCJHdWFyZGlhbiBHcm92ZVwiIDwke3Byb2Nlc3MuZW52LkVNQUlMX1VTRVJOQU1FfT5gO1xyXG4gICAgICAgIGNvbnN0IHRvOiBzdHJpbmcgPSBlbWFpbDtcclxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gYFdlbGNvbWUgdG8gR3VhcmRpYW4gR3JvdmUgLSAke25hbWV9J3MgQWNjb3VudCBEZXRhaWxzYDtcclxuICAgICAgICBjb25zdCBodG1sID0gYFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVwiZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmOyBtYXgtd2lkdGg6IDYwMHB4OyBtYXJnaW46IDAgYXV0bzsgY29sb3I6ICMzMzM7XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjlmYTsgcGFkZGluZzogMjBweDsgYm9yZGVyLXJhZGl1czogNXB4O1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxoMiBzdHlsZT1cImNvbG9yOiAjMmMzZTUwO1wiPldlbGNvbWUgdG8gR3VhcmRpYW4gR3JvdmUhPC9oMj5cclxuICAgICAgICAgICAgICAgICAgICA8cD5IZWxsbyAke3JlcS51c2VyLm5hbWV9LDwvcD5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IHBhZGRpbmc6IDE1cHg7IGJvcmRlci1yYWRpdXM6IDVweDsgbWFyZ2luOiAxNXB4IDA7IGJvcmRlci1sZWZ0OiA0cHggc29saWQgIzM0OThkYjtcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+WW91J3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgPHN0cm9uZz4ke3JvbGV9PC9zdHJvbmc+IGFjY291bnQgZm9yIDxzdHJvbmc+JHtuYW1lfTwvc3Ryb25nPi48L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPkhlcmUgYXJlIHRoZSBsb2dpbiBkZXRhaWxzOjwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIHN0eWxlPVwid2lkdGg6IDEwMCU7IGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwicGFkZGluZzogOHB4OyBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RkZDsgd2lkdGg6IDEyMHB4O1wiPjxzdHJvbmc+VXNlcm5hbWU6PC9zdHJvbmc+PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJwYWRkaW5nOiA4cHg7IGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1wiPiR7bmFtZX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJwYWRkaW5nOiA4cHg7XCI+PHN0cm9uZz5UZW1wb3JhcnkgUGFzc3dvcmQ6PC9zdHJvbmc+PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJwYWRkaW5nOiA4cHg7XCI+JHtnZW5lcmF0ZWRQYXNzd29yZH08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImNvbG9yOiAjZTc0YzNjOyBmb250LXdlaWdodDogYm9sZDtcIj5QbGVhc2UgY2hhbmdlIHRoaXMgcGFzc3dvcmQgYWZ0ZXIgZmlyc3QgbG9naW4uPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIDxwPklmIHlvdSBkaWRuJ3QgcmVxdWVzdCB0aGlzIGFjY291bnQgY3JlYXRpb24sIHBsZWFzZSBjb250YWN0IG91ciBzdXBwb3J0IGltbWVkaWF0ZWx5LjwvcD5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLXRvcDogMjBweDsgcGFkZGluZy10b3A6IDIwcHg7IGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5CZXN0IHJlZ2FyZHMsPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD48c3Ryb25nPlRoZSBHdWFyZGlhbiBHcm92ZSBUZWFtPC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImZvbnQtc2l6ZTogMTJweDsgY29sb3I6ICM3ZjhjOGQ7XCI+VGhpcyBpcyBhbiBhdXRvbWF0ZWQgbWVzc2FnZSAtIHBsZWFzZSBkbyBub3QgcmVwbHkgZGlyZWN0bHkgdG8gdGhpcyBlbWFpbC48L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYDtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBlbWFpbCB3aXRoIHRoZSB0ZW1wb3JhcnkgcGFzc3dvcmRcclxuICAgICAgICBhd2FpdCBzZW5kTWFpbChmcm9tLCB0bywgc3ViamVjdCwgaHRtbCk7XHJcblxyXG4gICAgICAgIGF3YWl0IHVzZXIuc2F2ZSgpO1xyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHsgbWVzc2FnZTogXCJVc2VyIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBwYXNzd29yZCBlbWFpbCBzZW50LlwiLCB1c2VyIH0pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAvLyBIYW5kbGUgTW9uZ29EQiBkdXBsaWNhdGUga2V5IGVycm9yICgxMTAwMClcclxuICAgICAgICAgICAgaWYgKChlcnJvciBhcyBhbnkpLmNvZGUgPT09IDExMDAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSB1c2VyIHdpdGggdGhpcyBuYW1lIGFuZCBlbWFpbCBhbHJlYWR5IGV4aXN0cy5cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLCBcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwOSBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLCByZXMsIHN0YXR1czogNTAwIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuXCIsIHJlcywgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICAgICAgfSAgICBcclxuICAgIH0gXHJcbn07XHJcblxyXG4vLyBBUEkgdG8gZWRpdCB1c2VyIHByb2ZpbGVcclxuZXhwb3J0IGNvbnN0IGVkaXRVc2VyUHJvZmlsZSA9IGFzeW5jKHJlcTogQ3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6UHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgY29uc3Qge3VzZXJJZCwgbmFtZSwgYmlydGhkYXksIGdlbmRlciwgYXZhdGFyLCByb2xlfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgocm9sZSkgJiYgIVsncGFyZW50JywgJ2FkbWluJywgJ293bmVyJ10uaW5jbHVkZXMocmVxLnVzZXIucm9sZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZvcmJpZGRlbjogWW91IGNhbm5vdCBjaGFuZ2Ugcm9sZSBub3IgZW1haWxcIiwgcmVzLCBzdGF0dXM6IDQwMyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB1c2VyO1xyXG5cclxuICAgICAgICBpZih1c2VySWQpe1xyXG4gICAgICAgICAgICBpZighY2hlY2tJZCh7aWQ6IHVzZXJJZCwgcmVzfSkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHJlcS51c2VyLl9pZC50b1N0cmluZygpICE9PSB1c2VySWQgJiYgIVsncGFyZW50JywgJ2FkbWluJywgJ293bmVyJ10uaW5jbHVkZXMocmVxLnVzZXIucm9sZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJGb3JiaWRkZW5cIiwgcmVzLCBzdGF0dXM6IDQwMyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXNlciA9IGF3YWl0IFVzZXIuZmluZEJ5SWQodXNlcklkKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdXNlcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVXNlciBub3QgZm91bmRcIiwgcmVzLCBzdGF0dXM6IDQwNH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihyZXEudXNlci5yb2xlICE9PSBcImFkbWluXCIgJiYgcmVxLnVzZXIuZW1haWwgIT09IHVzZXIuZW1haWwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZvcmJpZGRlblwiLCByZXMsIHN0YXR1czogNDAzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHVzZXIgPSByZXEudXNlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGEgdXNlciB3aXRoIHRoZSBzYW1lIGVtYWlsIGFuZCBuYW1lIGV4aXN0c1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSh7IGVtYWlsOiB1c2VyLmVtYWlsLCBuYW1lLCBfaWQ6IHsgJG5lOiB1c2VyLl9pZCB9IH0pO1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdVc2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiQSB1c2VyIHdpdGggdGhlIHNhbWUgZW1haWwgYW5kIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIsIHJlcywgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXNlci5uYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lKSB1c2VyLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIGlmIChiaXJ0aGRheSkgdXNlci5iaXJ0aGRheSA9IGJpcnRoZGF5O1xyXG4gICAgICAgIGlmIChnZW5kZXIpIHVzZXIuZ2VuZGVyID0gZ2VuZGVyO1xyXG4gICAgICAgIGlmIChhdmF0YXIpIHVzZXIuYXZhdGFyID0gYXZhdGFyO1xyXG4gICAgICAgIGlmIChyb2xlKSB1c2VyLnJvbGUgPSByb2xlOyBcclxuXHJcbiAgICAgICAgYXdhaXQgdXNlci5zYXZlKCk7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHttZXNzYWdlOiBcIlVzZXIgcHJvZmlsZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiLCB1c2VyfSk7XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJGYWlsZWQgdG8gdXBkYXRlLiBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLlwiLCByZXMsIHN0YXR1czogNTAwIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBBUEkgdG8gZGVsZXRlIHVzZXJcclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVVzZXIgPSBhc3luYyhyZXE6IEN1c3RvbVJlcXVlc3QsIHJlczpSZXNwb25zZSk6UHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgY29uc3Qge3VzZXJJZH0gPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXEudXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkXCIsIHJlcywgc3RhdHVzOiA0MDEgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdXNlcjtcclxuICAgICAgICBpZih1c2VySWQpe1xyXG4gICAgICAgICAgICBpZighY2hlY2tJZCh7aWQ6IHVzZXJJZCwgcmVzfSkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHJlcS51c2VyLl9pZC50b1N0cmluZygpICE9PSB1c2VySWQgJiYgIVsncGFyZW50JywgJ2FkbWluJywgJ293bmVyJ10uaW5jbHVkZXMocmVxLnVzZXIucm9sZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJGb3JiaWRkZW5cIiwgcmVzLCBzdGF0dXM6IDQwMyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXNlciA9IGF3YWl0IFVzZXIuZmluZEJ5SWQodXNlcklkKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdXNlcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVXNlciBub3QgZm91bmRcIiwgcmVzLCBzdGF0dXM6IDQwNH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihyZXEudXNlci5yb2xlICE9PSBcImFkbWluXCIgJiYgcmVxLnVzZXIuZW1haWwgIT09IHVzZXIuZW1haWwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZvcmJpZGRlblwiLCByZXMsIHN0YXR1czogNDAzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHVzZXIgPSByZXEudXNlcjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGRlbGV0aW5nIHRoZSBsYXN0IHBhcmVudCBpbiBhIGZhbWlseVxyXG4gICAgICAgIGNvbnN0IGZhbWlseSA9IGF3YWl0IEZhbWlseS5maW5kQnlJZCh1c2VyLmZhbWlseUlkKTtcclxuICAgICAgICBpZiAoZmFtaWx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudHNDb3VudCA9IGF3YWl0IFVzZXIuY291bnREb2N1bWVudHMoeyBmYW1pbHlJZDogZmFtaWx5Ll9pZCwgcm9sZTogJ3BhcmVudCcgfSk7XHJcbiAgICAgICAgICAgIGlmICh1c2VyLnJvbGUgPT09ICdwYXJlbnQnICYmIHBhcmVudHNDb3VudCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiQ2Fubm90IGRlbGV0ZSB0aGUgbGFzdCBwYXJlbnQgaW4gdGhlIGZhbWlseVwiLCByZXMsIHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdXNlciBmcm9tIHRoZSBmYW1pbHkgbWVtYmVycyBsaXN0XHJcbiAgICAgICAgICAgIGZhbWlseS5tZW1iZXJzID0gZmFtaWx5Lm1lbWJlcnMuZmlsdGVyKChtZW1iZXIpID0+IG1lbWJlci5faWQudG9TdHJpbmcoKSAhPT0gdXNlci5faWQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGZhbWlseS5zYXZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWxldGUgdGhlIHVzZXJcclxuICAgICAgICBhd2FpdCBVc2VyLmZpbmRCeUlkQW5kRGVsZXRlKHVzZXIuX2lkKTtcclxuICAgICAgXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoe21lc3NhZ2U6IFwiVXNlciBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiLCB1c2VyfSk7XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJGYWlsZWQgdG8gZGVsZXRlLiBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLlwiLCByZXMsIHN0YXR1czogNTAwIH0pO1xyXG4gICAgfVxyXG59IFxyXG5cclxuLy8gQVBJIHRvIHVwZGF0ZSBwYXNzd29yZFxyXG5leHBvcnQgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBhc3luYyAocmVxOiBDdXN0b21SZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHt1c2VySWQsIG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCwgY29uZmlybVBhc3N3b3JkIH0gPSByZXEuYm9keTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB1c2VyO1xyXG5cclxuICAgICAgICBpZih1c2VySWQpe1xyXG4gICAgICAgICAgICBpZighY2hlY2tJZCh7aWQ6IHVzZXJJZCwgcmVzfSkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHJlcS51c2VyLl9pZC50b1N0cmluZygpICE9PSB1c2VySWQgJiYgcmVxLnVzZXIucm9sZSAhPT0gXCJhZG1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRm9yYmlkZGVuXCIsIHJlcywgc3RhdHVzOiA0MDMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRCeUlkKHVzZXJJZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXVzZXIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIlVzZXIgbm90IGZvdW5kXCIsIHJlcywgc3RhdHVzOiA0MDR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB1c2VyID0gcmVxLnVzZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcclxuICAgICAgICBpZiAoIW9sZFBhc3N3b3JkIHx8ICFuZXdQYXNzd29yZCB8fCAhY29uZmlybVBhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJBbGwgZmllbGRzIGFyZSByZXF1aXJlZC5cIiwgcmVzLCBzdGF0dXM6IDQwMCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdQYXNzd29yZCAhPT0gY29uZmlybVBhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJQYXNzd29yZHMgZG8gbm90IG1hdGNoLlwiLCByZXMsIHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmVyaWZ5IG9sZCBwYXNzd29yZFxyXG4gICAgICAgIGNvbnN0IGlzTWF0Y2ggPSBhd2FpdCBiY3J5cHQuY29tcGFyZShvbGRQYXNzd29yZCwgdXNlci5wYXNzd29yZCk7XHJcbiAgICAgICAgaWYgKCFpc01hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJPbGQgcGFzc3dvcmQgaXMgaW5jb3JyZWN0LlwiLCByZXMsIHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5ldyBwYXNzd29yZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgb2xkIG9uZVxyXG4gICAgICAgIGNvbnN0IGlzU2FtZVBhc3N3b3JkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUobmV3UGFzc3dvcmQsIHJlcS51c2VyLnBhc3N3b3JkKTtcclxuICAgICAgICBpZiAoaXNTYW1lUGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIk5ldyBwYXNzd29yZCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG9sZCBwYXNzd29yZC5cIiwgcmVzLCBzdGF0dXM6IDQwMCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhc3N3b3JkUmVnZXggPSAvXig/PS4qW2Etel0pKD89LipbQS1aXSkoPz0uKlxcZCkoPz0uKltAJCElKj8mXSlbQS1aYS16XFxkQCQhJSo/Jl17OCx9JC87XHJcbiAgICAgICAgaWYgKCFwYXNzd29yZFJlZ2V4LnRlc3QobmV3UGFzc3dvcmQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMgbG9uZywgaW5jbHVkZSBhbiB1cHBlcmNhc2UgbGV0dGVyLCBsb3dlcmNhc2UgbGV0dGVyLCBhIG51bWJlciwgYW5kIGEgc3BlY2lhbCBjaGFyYWN0ZXIuXCIsXHJcbiAgICAgICAgICAgICAgICByZXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhc2ggbmV3IHBhc3N3b3JkXHJcbiAgICAgICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSBhd2FpdCBiY3J5cHQuaGFzaChuZXdQYXNzd29yZCwgMTApO1xyXG4gICAgICAgIHVzZXIucGFzc3dvcmQgPSBoYXNoZWRQYXNzd29yZDtcclxuICAgICAgICB1c2VyLmlzVGVtcFBhc3N3b3JkID0gZmFsc2U7XHJcbiAgICAgICAgYXdhaXQgdXNlci5zYXZlKCk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBzdWNjZXNzIHJlc3BvbnNlXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoeyBtZXNzYWdlOiBcIlBhc3N3b3JkIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5LlwiLCBwYXNzd29yZDogbmV3UGFzc3dvcmQgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHVwZGF0ZSBwYXNzd29yZC5cIiwgcmVzLCBzdGF0dXM6IDUwMCB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFQSSB0byBnZXQgdXNlcidzIHN0YXJzXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyU3RhcnMgPSBhc3luYyhyZXE6Q3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmICghcmVxLnVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZFwiLCByZXMsIHN0YXR1czogNDAxfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXMuc3RhdHVzKDIwMCkuc2VuZCh7bWVzc2FnZTpcIlN0YXJzIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIiwgc3RhcnM6IHJlcS51c2VyLnN0YXJzfSk7XHJcblxyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgcmV0cmlldmluZyB1c2VyIHN0YXJzXCIsIHJlcywgc3RhdHVzOiA1MDB9KTtcclxuICAgIH1cclxufSBcclxuXHJcbi8vIEFQSSB0byB1cGRhdGUgdXNlcidzIHN0YXJzXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyU3RhcnMgPSBhc3luYyhyZXE6Q3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnMgfTogeyBzdGFyczogbnVtYmVyIH0gPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXEudXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkXCIsIHJlcywgc3RhdHVzOiA0MDF9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGFycyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzdGFycyAhPT0gXCJudW1iZXJcIiB8fCBzdGFycyA8IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiU3RhcnMgbXVzdCBiZSBhIHZhbGlkIG51bWJlci5cIiwgcmVzLCBzdGF0dXM6IDQwMH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxLnVzZXIuc3RhcnMgKz0gc3RhcnM7XHJcbiAgICAgICAgYXdhaXQgcmVxLnVzZXIuc2F2ZSgpO1xyXG5cclxuICAgICAgICBpZighcmVxLnVzZXIuZmFtaWx5SWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiTm8gZmFtaWx5IGlkXCIsIHJlcywgc3RhdHVzOiA0MDB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlKHJlcS51c2VyLmZhbWlseUlkLCB7ICRpbmM6IHsgdG90YWxTdGFyczogc3RhcnMgfSB9KTtcclxuICAgICAgICBcclxuICAgICAgICBhd2FpdCByZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzKHJlcS51c2VyLmZhbWlseUlkLCByZXEudXNlcik7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHsgbWVzc2FnZTogXCJVc2VyIHN0YXJzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIsIHVzZXI6IHJlcS51c2VyIH0pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgdXBkYXRpbmcgdXNlciBzdGFyc1wiLCByZXMsIHN0YXR1czogNTAwfSk7XHJcbiAgICB9XHJcbn0gXHJcblxyXG4vLyBBUEkgdG8gZ2V0IHVzZXIncyBjb2luc1xyXG5leHBvcnQgY29uc3QgZ2V0VXNlckNvaW5zID0gYXN5bmMocmVxOkN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoe21lc3NhZ2U6XCJDb2lucyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsIGNvaW5zOiByZXEudXNlci5jb2luc30pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgcmV0cmlldmluZyB1c2VyIGNvaW5zXCIsIHJlcywgc3RhdHVzOiA1MDB9KTtcclxuICAgIH1cclxufSBcclxuXHJcbi8vIEFQSSB0byB1cGRhdGUgdXNlcidzIGNvaW5zXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyQ29pbnMgPSBhc3luYyhyZXE6Q3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGNvbnN0IHsgY29pbnMgfTogeyBjb2luczogbnVtYmVyIH0gPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXEudXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkXCIsIHJlcywgc3RhdHVzOiA0MDF9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb2lucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjb2lucyAhPT0gXCJudW1iZXJcIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJTdGFycyBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyLlwiLCByZXMsIHN0YXR1czogNDAwfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXEudXNlci5jb2lucyArPSBjb2lucztcclxuICAgICAgICBhd2FpdCByZXEudXNlci5zYXZlKCk7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHsgbWVzc2FnZTogXCJVc2VyIGNvaW5zIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIsIHVzZXI6IHJlcS51c2VyIH0pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgdXBkYXRpbmcgdXNlciBjb2luc1wiLCByZXMsIHN0YXR1czogNTAwfSk7XHJcbiAgICB9XHJcbn0gXHJcblxyXG5cclxuLy8gQVBJIHRvIGdldCB1c2VyJ3MgbG9jYXRpb25cclxuZXhwb3J0IGNvbnN0IGdldExvY2F0aW9uID0gYXN5bmMocmVxOkN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoe21lc3NhZ2U6XCJMb2NhdGlvbiByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsIGxvY2F0aW9uOiByZXEudXNlci5jdXJyZW50TG9jYXRpb259KTtcclxuXHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJFcnJvciByZXRyaWV2aW5nIHVzZXIgbG9jYXRpb25cIiwgcmVzLCBzdGF0dXM6IDUwMH0pO1xyXG4gICAgfVxyXG59IFxyXG5cclxuLy8gQVBJIHRvIHVwZGF0ZSB1c2VyJ3MgY3VycmVudCBsb2NhdGlvblxyXG5leHBvcnQgY29uc3QgdXBkYXRlTG9jYXRpb24gPSBhc3luYyhyZXE6Q3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudExvY2F0aW9uIH06IHsgY3VycmVudExvY2F0aW9uOiBzdHJpbmcgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50TG9jYXRpb24gIT09IFwic3RyaW5nXCIgfHwgY3VycmVudExvY2F0aW9uLnRyaW0oKSA9PT0gXCJcIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJMb2NhdGlvbiBtdXN0IGJlIHZhbGlkLlwiLCByZXMsIHN0YXR1czogNDAwfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXEudXNlci5jdXJyZW50TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XHJcbiAgICAgICAgYXdhaXQgcmVxLnVzZXIuc2F2ZSgpO1xyXG5cclxuICAgICAgICByZXMuc3RhdHVzKDIwMCkuc2VuZCh7IG1lc3NhZ2U6IFwiVXNlciBsb2NhdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiLCB1c2VyOiByZXEudXNlciB9KTtcclxuICAgIH1jYXRjaChlcnJvcil7XHJcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkVycm9yIHVwZGF0aW5nIHVzZXIgbG9jYXRpb25cIiwgcmVzLCBzdGF0dXM6IDUwMH0pO1xyXG4gICAgfVxyXG59ICBcclxuXHJcbi8vIEFQSSB0byBnZXQgdXNlcidzIHJhbmtcclxuZXhwb3J0IGNvbnN0IGdldFVzZXJSYW5rID0gYXN5bmMocmVxOkN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoe21lc3NhZ2U6XCJSYW5rIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIiwgUmFuazogcmVxLnVzZXIucmFua0luRmFtaWx5fSk7XHJcbiAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJFcnJvciByZXRyaWV2aW5nIHVzZXIgcmFua1wiLCByZXMsIHN0YXR1czogNTAwfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBBUEkgdG8gdXBkYXRlIHVzZXIncyByYW5rXHJcbi8qZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJSYW5rID0gYXN5bmMocmVxOkN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBjb25zdCB7IHJhbmsgfTogeyByYW5rOiBudW1iZXIgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJhbmsgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcmFuayAhPT0gXCJudW1iZXJcIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJSYW5rIG11c3QgYmUgYSB2YWxpZCBudW1iZXIuXCIsIHJlcywgc3RhdHVzOiA0MDB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcS51c2VyLnJhbmtJbkZhbWlseSA9IHJhbms7XHJcbiAgICAgICAgYXdhaXQgcmVxLnVzZXIuc2F2ZSgpO1xyXG5cclxuICAgICAgICByZXMuc3RhdHVzKDIwMCkuc2VuZCh7IG1lc3NhZ2U6IFwiVXNlciByYW5rIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIsIHVzZXI6IHJlcS51c2VyIH0pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgdXBkYXRpbmcgdXNlciByYW5rXCIsIHJlcywgc3RhdHVzOiA1MDB9KTtcclxuICAgIH1cclxufTsqL1xyXG5cclxuLy8gQVBJIHRvIGdldCB1c2VyJ3MgaW50ZXJlc2V0c1xyXG5leHBvcnQgY29uc3QgZ2V0VXNlckludGVyZXN0cyA9IGFzeW5jKHJlcTpDdXN0b21SZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgaWYgKCFyZXEudXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkXCIsIHJlcywgc3RhdHVzOiA0MDF9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHsgbWVzc2FnZTogXCJJbnRlcmVzdHMgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLCBJbnRlcmVzdHM6IHJlcS51c2VyLmludGVyZXN0c30pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJFcnJvciByZXRyaWV2aW5nIHVzZXIgaW50ZXJlc3RzXCIsIHJlcywgc3RhdHVzOiA1MDB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFQSSB0byBzdGFydCBhbiBhZHZlbnR1cmVcclxuZXhwb3J0IGNvbnN0IHN0YXJ0QWR2ZW50dXJlID0gYXN5bmMgKHJlcTogQ3VzdG9tUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7YWR2ZW50dXJlSWR9ID0gcmVxLmJvZHk7XHJcblxyXG4gICAgICAgIGlmICghcmVxLnVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZFwiLCByZXMsIHN0YXR1czogNDAxIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gcmVxLnVzZXIuX2lkO1xyXG5cclxuICAgICAgICBpZighY2hlY2tJZCh7aWQ6IGFkdmVudHVyZUlkLCByZXN9KSkgcmV0dXJuO1xyXG4gICAgICAgIGlmKCFjaGVja0lkKHtpZDogdXNlcklkLnRvU3RyaW5nKCksIHJlc30pKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGFkdmVudHVyZSBieSBhZHZlbnR1cmVJZFxyXG4gICAgICAgIGNvbnN0IGFkdmVudHVyZSA9IGF3YWl0IEFkdmVudHVyZS5maW5kQnlJZChhZHZlbnR1cmVJZCk7XHJcbiAgICAgICAgaWYgKCFhZHZlbnR1cmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkFkdmVudHVyZSBub3QgZm91bmRcIiwgcmVzLCBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQWR2ZW50dXJlUHJvZ3Jlc3MgPSByZXEudXNlci5hZHZlbnR1cmVzLmZpbmQoXHJcbiAgICAgICAgICAgIChhZHZlbnR1cmVQcm9ncmVzcykgPT4gXHJcbiAgICAgICAgICAgICAgICBhZHZlbnR1cmVQcm9ncmVzcy5hZHZlbnR1cmVJZC5lcXVhbHMoYWR2ZW50dXJlSWQpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdBZHZlbnR1cmVQcm9ncmVzcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiQWR2ZW50dXJlIGFscmVhZHkgc3RhcnRlZFwiLCByZXMsIHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGFkdmVudHVyZSB0byB1c2VyJ3MgYWR2ZW50dXJlc1xyXG4gICAgICAgIGNvbnN0IG5ld0FkdmVudHVyZVByb2dyZXNzIDogSUFkdmVudHVyZVByb2dyZXNzID0ge1xyXG4gICAgICAgICAgICBhZHZlbnR1cmVJZDogYWR2ZW50dXJlSWQsXHJcbiAgICAgICAgICAgIGNoYWxsZW5nZXM6IGFkdmVudHVyZS5jaGFsbGVuZ2VzLm1hcCgoY2hhbGxlbmdlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZS5faWQsXHJcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlZDogZmFsc2UsICBcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6IFwiaW4tcHJvZ3Jlc3NcIixcclxuICAgICAgICAgICAgaXNBZHZlbnR1cmVDb21wbGV0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBzdGFyc1Jld2FyZDogYWR2ZW50dXJlLnN0YXJzUmV3YXJkLFxyXG4gICAgICAgICAgICBjb2luc1Jld2FyZDogYWR2ZW50dXJlLmNvaW5zUmV3YXJkLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXEudXNlci5hZHZlbnR1cmVzLnB1c2gobmV3QWR2ZW50dXJlUHJvZ3Jlc3MpO1xyXG4gICAgICAgIGF3YWl0IHJlcS51c2VyLnNhdmUoKTtcclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoeyBtZXNzYWdlOiBcIkFkdmVudHVyZSBzdGFydGVkIHN1Y2Nlc3NmdWxseVwiLCB1c2VyOiByZXEudXNlciB9KTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHN0YXJ0aW5nIHRoZSBhZHZlbnR1cmUuXCIsIHJlcywgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29tcGxldGVDaGFsbGVuZ2UgPSBhc3luYyAocmVxOiBDdXN0b21SZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgYWR2ZW50dXJlSWQsIGNoYWxsZW5nZUlkIH0gPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKCFjaGVja0lkKHsgaWQ6IGFkdmVudHVyZUlkLCByZXMgfSkpIHJldHVybjtcclxuICAgICAgICBpZiAoIWNoZWNrSWQoeyBpZDogY2hhbGxlbmdlSWQsIHJlcyB9KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSByZXEudXNlcjtcclxuICAgICAgICBjb25zdCBhZHZlbnR1cmVQcm9ncmVzcyA9IHVzZXIuYWR2ZW50dXJlcy5maW5kKFxyXG4gICAgICAgICAgICAoYWR2ZW50dXJlKSA9PiBhZHZlbnR1cmUuYWR2ZW50dXJlSWQuZXF1YWxzKGFkdmVudHVyZUlkKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKCFhZHZlbnR1cmVQcm9ncmVzcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiQWR2ZW50dXJlIG5vdCBmb3VuZCBpbiB1c2VyJ3MgcHJvZmlsZVwiLCByZXMsIHN0YXR1czogNDA0IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2hhbGxlbmdlID0gYWR2ZW50dXJlUHJvZ3Jlc3MuY2hhbGxlbmdlcy5maW5kKFxyXG4gICAgICAgICAgICAoY2hhbGxlbmdlKSA9PiBjaGFsbGVuZ2UuY2hhbGxlbmdlSWQuZXF1YWxzKGNoYWxsZW5nZUlkKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKCFjaGFsbGVuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkNoYWxsZW5nZSBub3QgZm91bmQgaW4gYWR2ZW50dXJlXCIsIHJlcywgc3RhdHVzOiA0MDQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGZXRjaCB0aGUgZnVsbCBhZHZlbnR1cmUgdG8gZ2V0IGNoYWxsZW5nZSByZXdhcmRzXHJcbiAgICAgICAgY29uc3QgYWR2ZW50dXJlID0gYXdhaXQgQWR2ZW50dXJlLmZpbmRCeUlkKGFkdmVudHVyZUlkKS5sZWFuKCk7XHJcblxyXG4gICAgICAgIGlmICghYWR2ZW50dXJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJBZHZlbnR1cmUgbm90IGZvdW5kXCIsIHJlcywgc3RhdHVzOiA0MDQgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXRDaGFsbGVuZ2UgPSBhZHZlbnR1cmUuY2hhbGxlbmdlcy5maW5kKGNoID0+XHJcbiAgICAgICAgICAgIGNoLl9pZC5lcXVhbHMoY2hhbGxlbmdlSWQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCF0YXJnZXRDaGFsbGVuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkNoYWxsZW5nZSBkYXRhIG5vdCBmb3VuZCBpbiBhZHZlbnR1cmVcIiwgcmVzLCBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1hcmsgY2hhbGxlbmdlIGFzIGNvbXBsZXRlIGFuZCBhZGQgcmV3YXJkc1xyXG4gICAgICAgIGNoYWxsZW5nZS5pc0NvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgY2hhbGxlbmdlLmNvbXBsZXRlZEF0ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnNSZXdhcmQgPSB0YXJnZXRDaGFsbGVuZ2Uuc3RhcnNSZXdhcmQ7XHJcbiAgICAgICAgY29uc3QgY29pbnNSZXdhcmQgPSB0YXJnZXRDaGFsbGVuZ2UuY29pbnNSZXdhcmQ7XHJcblxyXG4gICAgICAgIHVzZXIuc3RhcnMgKz0gc3RhcnNSZXdhcmQ7XHJcbiAgICAgICAgdXNlci5jb2lucyArPSBjb2luc1Jld2FyZDtcclxuXHJcbiAgICAgICAgYWR2ZW50dXJlUHJvZ3Jlc3MucHJvZ3Jlc3MgPSAoYWR2ZW50dXJlUHJvZ3Jlc3MuY2hhbGxlbmdlcy5maWx0ZXIoY2hhbGxlbmdlID0+IGNoYWxsZW5nZS5pc0NvbXBsZXRlZCkubGVuZ3RoIC8gYWR2ZW50dXJlUHJvZ3Jlc3MuY2hhbGxlbmdlcy5sZW5ndGgpICogMTAwO1xyXG5cclxuICAgICAgICBsZXQgYWR2ZW50dXJlU3RhcnMgPSAwO1xyXG4gICAgICAgIGlmIChhZHZlbnR1cmVQcm9ncmVzcy5wcm9ncmVzcyA9PT0gMTAwKSB7XHJcbiAgICAgICAgICAgIGFkdmVudHVyZVByb2dyZXNzLmlzQWR2ZW50dXJlQ29tcGxldGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWR2ZW50dXJlUHJvZ3Jlc3Muc3RhdHVzID0gJ2NvbXBsZXRlZCc7XHJcbiAgICAgICAgICAgIGFkdmVudHVyZVN0YXJzID0gYWR2ZW50dXJlUHJvZ3Jlc3Muc3RhcnNSZXdhcmQ7XHJcblxyXG4gICAgICAgICAgICB1c2VyLmNvaW5zICs9IGFkdmVudHVyZVByb2dyZXNzLmNvaW5zUmV3YXJkO1xyXG4gICAgICAgICAgICB1c2VyLnN0YXJzICs9IGFkdmVudHVyZVN0YXJzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBmYW1pbHkgdG90YWwgc3RhcnNcclxuICAgICAgICBpZiAodXNlci5mYW1pbHlJZCkge1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFN0YXJzID0gc3RhcnNSZXdhcmQgKyBhZHZlbnR1cmVTdGFycztcclxuICAgICAgICAgICAgYXdhaXQgRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlKHVzZXIuZmFtaWx5SWQsIHtcclxuICAgICAgICAgICAgICAgICRpbmM6IHsgdG90YWxTdGFyczogdG90YWxTdGFycyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhd2FpdCByZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzKHVzZXIuZmFtaWx5SWQsIHVzZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdXNlci5zYXZlKCk7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgbWVzc2FnZTogXCJDaGFsbGVuZ2UgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLCBhZHZlbnR1cmVQcm9ncmVzcyB9KTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGNvbXBsZXRpbmcgdGhlIGNoYWxsZW5nZS5cIiwgcmVzLCBzdGF0dXM6IDUwMCB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEFQSSB0byBnZXQgdXNlcidzIGFkdmVudHVyZXNcclxuZXhwb3J0IGNvbnN0IGdldFVzZXJBZHZlbnR1cmVzID0gYXN5bmMocmVxOkN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeXtcclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoeyBtZXNzYWdlOiBcIlVzZXIgYWR2ZW50dXJlcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsIEFkdmVudHVyZTogcmVxLnVzZXIuYWR2ZW50dXJlc30pO1xyXG4gICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiRXJyb3IgcmV0cmlldmluZyB1c2VyIGFkdmVudHVyZXNcIiwgcmVzLCBzdGF0dXM6IDUwMH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy9BUEkgdG8gZ2V0IHVzZXIncyBwdXJjaGFzZWQgaXRlbXNcclxuZXhwb3J0IGNvbnN0IGdldFVzZXJQdXJjaGFzZWRJdGVtcyA9IGFzeW5jIChyZXE6IEN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICBpZiAoIXJlcS51c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWRcIiwgcmVzLCBzdGF0dXM6IDQwMSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCByZXEudXNlci5faWQ7XHJcblxyXG4gICAgICAgIGlmICghY2hlY2tJZCh7IGlkOiB0YXJnZXRVc2VySWQsIHJlcyB9KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBpc0F1dGhvcml6ZWQgPSByZXEudXNlci5faWQudG9TdHJpbmcoKSA9PT0gdGFyZ2V0VXNlcklkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCFpc0F1dGhvcml6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkZvcmJpZGRlblwiLCByZXMsIHN0YXR1czogNDAzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmV0Y2ggb25seSBpdGVtSWRzIGZyb20gcHVyY2hhc2VkSXRlbXNcclxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kQnlJZCh0YXJnZXRVc2VySWQpLnNlbGVjdCgncHVyY2hhc2VkSXRlbXMuaXRlbUlkJyk7XHJcblxyXG4gICAgICAgIGlmICghdXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih7IG1lc3NhZ2U6IFwiVXNlciBub3QgZm91bmRcIiwgcmVzLCBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHB1cmNoYXNlZEl0ZW1JZHMgPSB1c2VyLnB1cmNoYXNlZEl0ZW1zLm1hcCgoaXRlbTogYW55KSA9PiBpdGVtLml0ZW1JZCk7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgbWVzc2FnZTogXCJQdXJjaGFzZWQgaXRlbXMgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLCBwdXJjaGFzZWRJdGVtczogcHVyY2hhc2VkSXRlbUlkcyB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIkVycm9yIHJldHJpZXZpbmcgcHVyY2hhc2VkIGl0ZW1zXCIsIHJlcywgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vL0FQSSB0byBnZXQgdXNlcidzIGF2YXRhclxyXG5leHBvcnQgY29uc3QgZ2V0VXNlckF2YXRhciA9IGFzeW5jIChyZXE6IEN1c3RvbVJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcclxuICAgIHRyeSB7XHJcblxyXG4gICAgICAgIGlmICghcmVxLnVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZFwiLCByZXMsIHN0YXR1czogNDAxfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB1c2VyID0gcmVxLnVzZXI7XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHttZXNzYWdlOiBcIkF2YXRhciByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsIGF2YXRhcjogdXNlci5hdmF0YXIgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHsgbWVzc2FnZTogXCJFcnJvciBmZXRjaGluZyBhdmF0YXJcIiwgcmVzLCBzdGF0dXM6IDUwMH0pO1xyXG4gICAgfVxyXG59OyJdLCJuYW1lcyI6WyJjb21wbGV0ZUNoYWxsZW5nZSIsImNyZWF0ZVVzZXIiLCJkZWxldGVVc2VyIiwiZWRpdFVzZXJQcm9maWxlIiwiZ2V0TG9jYXRpb24iLCJnZXRVc2VyQWR2ZW50dXJlcyIsImdldFVzZXJBdmF0YXIiLCJnZXRVc2VyQnlJZCIsImdldFVzZXJDb2lucyIsImdldFVzZXJJbnRlcmVzdHMiLCJnZXRVc2VyUHVyY2hhc2VkSXRlbXMiLCJnZXRVc2VyUmFuayIsImdldFVzZXJTdGFycyIsImdldFVzZXJzIiwic3RhcnRBZHZlbnR1cmUiLCJ1cGRhdGVMb2NhdGlvbiIsInVwZGF0ZVBhc3N3b3JkIiwidXBkYXRlVXNlckNvaW5zIiwidXBkYXRlVXNlclN0YXJzIiwicmVxIiwicmVzIiwidXNlcnMiLCJVc2VyIiwiZmluZCIsInN0YXR1cyIsInNlbmQiLCJlcnJvciIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwidXNlcklkIiwiYm9keSIsInVzZXIiLCJ0YXJnZXRVc2VySWQiLCJfaWQiLCJjaGVja0lkIiwiaWQiLCJwcm9qZWN0aW9uIiwiZmluZEJ5SWQiLCJzZWxlY3QiLCJ0b1N0cmluZyIsImluY2x1ZGVzIiwicm9sZSIsImVtYWlsIiwianNvbiIsImRhdGEiLCJuYW1lIiwiYmlydGhkYXkiLCJnZW5kZXIiLCJhdmF0YXIiLCJpbnRlcmVzdHMiLCJleGlzdGluZ1VzZXIiLCJmaW5kT25lIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRHZW5kZXJzIiwidmFsaWRSb2xlcyIsImlzTmFOIiwiRGF0ZSIsImdldFRpbWUiLCJnZW5lcmF0ZWRQYXNzd29yZCIsImdlbmVyYXRlU2VjdXJlUGFzc3dvcmQiLCJoYXNoZWRQYXNzd29yZCIsImJjcnlwdCIsImhhc2giLCJmYW1pbHkiLCJGYW1pbHkiLCJjcmVhdGUiLCJwYXNzd29yZCIsImZhbWlseUlkIiwibWVtYmVycyIsInB1c2giLCJzYXZlIiwicmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcyIsImZyb20iLCJwcm9jZXNzIiwiZW52IiwiRU1BSUxfVVNFUk5BTUUiLCJ0byIsInN1YmplY3QiLCJodG1sIiwic2VuZE1haWwiLCJFcnJvciIsImNvZGUiLCIkbmUiLCJwYXJlbnRzQ291bnQiLCJjb3VudERvY3VtZW50cyIsImZpbHRlciIsIm1lbWJlciIsImZpbmRCeUlkQW5kRGVsZXRlIiwib2xkUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsImNvbmZpcm1QYXNzd29yZCIsImlzTWF0Y2giLCJjb21wYXJlIiwiaXNTYW1lUGFzc3dvcmQiLCJwYXNzd29yZFJlZ2V4IiwidGVzdCIsImlzVGVtcFBhc3N3b3JkIiwic3RhcnMiLCJ1bmRlZmluZWQiLCJmaW5kQnlJZEFuZFVwZGF0ZSIsIiRpbmMiLCJ0b3RhbFN0YXJzIiwiY29pbnMiLCJsb2NhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInRyaW0iLCJSYW5rIiwicmFua0luRmFtaWx5IiwiSW50ZXJlc3RzIiwiYWR2ZW50dXJlSWQiLCJhZHZlbnR1cmUiLCJBZHZlbnR1cmUiLCJleGlzdGluZ0FkdmVudHVyZVByb2dyZXNzIiwiYWR2ZW50dXJlcyIsImFkdmVudHVyZVByb2dyZXNzIiwiZXF1YWxzIiwibmV3QWR2ZW50dXJlUHJvZ3Jlc3MiLCJjaGFsbGVuZ2VzIiwibWFwIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlSWQiLCJpc0NvbXBsZXRlZCIsImlzQWR2ZW50dXJlQ29tcGxldGVkIiwic3RhcnNSZXdhcmQiLCJjb2luc1Jld2FyZCIsInByb2dyZXNzIiwibGVhbiIsInRhcmdldENoYWxsZW5nZSIsImNoIiwiY29tcGxldGVkQXQiLCJsZW5ndGgiLCJhZHZlbnR1cmVTdGFycyIsImlzQXV0aG9yaXplZCIsInB1cmNoYXNlZEl0ZW1JZHMiLCJwdXJjaGFzZWRJdGVtcyIsIml0ZW0iLCJpdGVtSWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBOGtCYUE7ZUFBQUE7O1FBcGhCQUM7ZUFBQUE7O1FBa01BQztlQUFBQTs7UUExREFDO2VBQUFBOztRQXFRQUM7ZUFBQUE7O1FBeU5BQztlQUFBQTs7UUE4Q0FDO2VBQUFBOztRQXJyQkFDO2VBQUFBOztRQTBZQUM7ZUFBQUE7O1FBMkdBQztlQUFBQTs7UUErSkFDO2VBQUFBOztRQWxNQUM7ZUFBQUE7O1FBbkhBQztlQUFBQTs7UUF6V0FDO2VBQUFBOztRQTRnQkFDO2VBQUFBOztRQXRFQUM7ZUFBQUE7O1FBcEtBQztlQUFBQTs7UUErSEFDO2VBQUFBOztRQTFDQUM7ZUFBQUE7OzsrREFyWU07MkJBQ0U7dUJBQ007eUJBRUg7Z0NBQ0U7NkJBRUg7OENBQ3NCOzhCQUVwQjt3Q0FDYzs7Ozs7O0FBR2hDLE1BQU1MLFdBQVcsT0FBTU0sS0FBY0M7SUFDeEMsSUFBRztRQUNDLE1BQU1DLFFBQVEsTUFBTUMsZUFBSSxDQUFDQyxJQUFJO1FBQzdCSCxJQUFJSSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDSjtJQUN6QixFQUFDLE9BQU1LLE9BQU07UUFDVCxPQUFPQyxJQUFBQSxpQkFBVSxFQUFDO1lBQUVDLFNBQVM7WUFBMEJSO1lBQUtJLFFBQVE7UUFBRztJQUMzRTtBQUNKO0FBR08sTUFBTWpCLGNBQWMsT0FBT1ksS0FBb0JDO0lBQ2xELElBQUk7UUFDQSxNQUFNLEVBQUVTLE1BQU0sRUFBRSxHQUFHVixJQUFJVyxJQUFJO1FBRTNCLElBQUksQ0FBQ1gsSUFBSVksSUFBSSxFQUFFO1lBQ1gsT0FBT0osSUFBQUEsaUJBQVUsRUFBQztnQkFBRUMsU0FBUztnQkFBZ0JSO2dCQUFLSSxRQUFRO1lBQUk7UUFDbEU7UUFFQSxN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