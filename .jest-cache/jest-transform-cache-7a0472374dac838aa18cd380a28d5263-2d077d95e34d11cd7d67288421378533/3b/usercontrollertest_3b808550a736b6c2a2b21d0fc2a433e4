3dff85f5bd08971caf68794315bd7eee
"use strict";
// Mock all dependencies
jest.mock('../../src/models/user.model');
jest.mock('../../src/models/adventure.model');
jest.mock('../../src/models/family.model');
jest.mock('../../src/services/email.service');
jest.mock('../../src/utils/generateSecurePassword');
jest.mock('../../src/utils/recalculateFamilyMemberRanks');
jest.mock('../../src/utils/checkId');
jest.mock('bcrypt');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _setup = require("../setup");
const _usercontroller = require("../../src/controllers/user.controller");
const _usermodel = require("../../src/models/user.model");
const _generateSecurePassword = /*#__PURE__*/ _interop_require_wildcard(require("../../src/utils/generateSecurePassword"));
const _checkId = /*#__PURE__*/ _interop_require_wildcard(require("../../src/utils/checkId"));
const _adventuremodel = require("../../src/models/adventure.model");
const _familymodel = require("../../src/models/family.model");
const _emailservice = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/email.service"));
const _recalculateFamilyMemberRanks = /*#__PURE__*/ _interop_require_wildcard(require("../../src/utils/recalculateFamilyMemberRanks"));
const _bcrypt = /*#__PURE__*/ _interop_require_wildcard(require("bcrypt"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockUser = _usermodel.User;
const mockAdventure = _adventuremodel.Adventure;
const mockFamily = _familymodel.Family;
const mockGenerateSecurePassword = _generateSecurePassword;
const mockCheckId = _checkId;
const mockEmailService = _emailservice;
const mockRecalculateFamilyMemberRanks = _recalculateFamilyMemberRanks;
const mockBcrypt = _bcrypt;
describe('User Controller Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup User model methods
        mockUser.find = jest.fn();
        mockUser.findOne = jest.fn();
        mockUser.findById = jest.fn();
        mockUser.create = jest.fn();
        mockUser.findByIdAndUpdate = jest.fn();
        mockUser.findByIdAndDelete = jest.fn();
        mockUser.countDocuments = jest.fn();
        // Setup Adventure model methods
        mockAdventure.findById = jest.fn();
        // Setup Family model methods
        mockFamily.findOne = jest.fn();
        mockFamily.findById = jest.fn();
        mockFamily.findByIdAndUpdate = jest.fn();
        // Setup utility mocks
        mockGenerateSecurePassword.generateSecurePassword.mockReturnValue('TempPass123!');
        mockCheckId.checkId.mockReturnValue(true);
        jest.spyOn(mockEmailService, 'sendMail').mockResolvedValue(undefined);
        jest.spyOn(mockRecalculateFamilyMemberRanks, 'recalculateFamilyMemberRanks').mockResolvedValue(undefined);
        jest.spyOn(_bcrypt, 'hash').mockResolvedValue('hashedPassword');
        jest.spyOn(_bcrypt, 'compare').mockResolvedValue(true);
    });
    // 1. test getUsers API
    describe('getUsers', ()=>{
        it('should return all users successfully', async ()=>{
            const mockUsers = [
                _setup.testUtils.createMockUser({
                    name: 'John'
                }),
                _setup.testUtils.createMockUser({
                    name: 'Jane',
                    _id: '507f1f77bcf86cd799439013'
                })
            ];
            mockUser.find.mockResolvedValue(mockUsers);
            const mockReq = _setup.testUtils.createMockRequest();
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUsers)(mockReq, mockRes);
            expect(mockUser.find).toHaveBeenCalledTimes(1);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith(mockUsers);
        });
        it('should handle database errors', async ()=>{
            mockUser.find.mockRejectedValue(new Error('Database connection failed'));
            const mockReq = _setup.testUtils.createMockRequest();
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUsers)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error retrieving users'
            });
        });
    });
    // 2. test getUserById API
    describe('getUserById', ()=>{
        it('should return user by ID successfully', async ()=>{
            const mockUser_data = _setup.testUtils.createMockUser();
            const mockUserDoc = {
                ...mockUser_data,
                select: jest.fn().mockResolvedValue(mockUser_data)
            };
            mockUser.findById.mockReturnValue(mockUserDoc);
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser(),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserById)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                message: "Retrieving user successfully",
                user: mockUser_data
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserById)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 404 if user not found', async ()=>{
            const mockUserDoc = {
                select: jest.fn().mockResolvedValue(null)
            };
            mockUser.findById.mockReturnValue(mockUserDoc);
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser(),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserById)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'User not found'
            });
        });
        it('should return 403 if forbidden access', async ()=>{
            const mockUser_data = _setup.testUtils.createMockUser({
                email: 'different@email.com'
            });
            const mockUserDoc = {
                select: jest.fn().mockResolvedValue(mockUser_data)
            };
            mockUser.findById.mockReturnValue(mockUserDoc);
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser({
                    _id: 'different-id',
                    role: 'child'
                }),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserById)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(403);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Forbidden'
            });
        });
    });
    // 3. test createUser API
    describe('createUser', ()=>{
        const validUserData = {
            name: 'Test Child',
            birthday: '2010-01-01',
            gender: 'male',
            role: 'child',
            avatar: '/avatar.png',
            interests: [
                'reading',
                'sports'
            ]
        };
        it('should create user successfully', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent',
                email: 'parent@test.com'
            });
            const mockFamilyData = _setup.testUtils.createMockFamily({
                email: 'parent@test.com',
                members: []
            });
            const mockCreatedUser = _setup.testUtils.createMockUser(validUserData);
            mockUser.findOne.mockResolvedValue(null); // No existing user
            mockFamily.findOne.mockResolvedValue(mockFamilyData);
            mockUser.create.mockResolvedValue(mockCreatedUser);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: validUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockUser.create).toHaveBeenCalled();
            expect(mockEmailService.sendMail).toHaveBeenCalled();
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null,
                body: validUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 403 if user is child', async ()=>{
            const mockChild = _setup.testUtils.createMockUser({
                role: 'child'
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockChild,
                body: validUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(403);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Forbidden'
            });
        });
        it('should return 400 if required fields missing', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const incompleteData = {
                name: 'Test'
            }; // Missing required fields
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: incompleteData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'All required fields must be filled.'
            });
        });
        it('should return 409 if username already taken', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent',
                email: 'parent@test.com'
            });
            const existingUser = _setup.testUtils.createMockUser({
                name: 'Test Child',
                email: 'parent@test.com'
            });
            mockUser.findOne.mockResolvedValue(existingUser);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: validUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(409);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'This username is already taken for this email.'
            });
        });
        it('should return 400 if interests is not array', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const invalidData = {
                ...validUserData,
                interests: 'not-an-array'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Interests must be an array.'
            });
        });
        it('should return 400 if invalid gender', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const invalidData = {
                ...validUserData,
                gender: 'invalid'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: "Gender must be either 'male' or 'female'."
            });
        });
        it('should return 400 if invalid role', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const invalidData = {
                ...validUserData,
                role: 'invalid'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid role.'
            });
        });
        it('should return 400 if invalid birthday', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const invalidData = {
                ...validUserData,
                birthday: 'invalid-date'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid birthday format.'
            });
        });
        it('should return 404 if family not found', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            mockUser.findOne.mockResolvedValue(null); // No existing user
            mockFamily.findOne.mockResolvedValue(null); // No family found
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: validUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.createUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Family not found.'
            });
        });
    });
    // 4. test editUserProfile API
    describe('editUserProfile', ()=>{
        it('should edit user profile successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            mockUser.findById.mockResolvedValue(mockUserData);
            mockUser.findOne.mockResolvedValue(null); // No duplicate name
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    name: 'Updated Name',
                    birthday: '1990-01-01',
                    gender: 'male',
                    avatar: '/new-avatar.png'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.editUserProfile)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "User profile updated successfully",
                user: expect.any(Object)
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.editUserProfile)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 403 if child tries to change role', async ()=>{
            const mockChild = _setup.testUtils.createMockUser({
                role: 'child'
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockChild,
                body: {
                    role: 'parent'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.editUserProfile)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(403);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Forbidden: You cannot change role nor email'
            });
        });
        it('should return 404 if user not found', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            mockUser.findById.mockResolvedValue(null);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.editUserProfile)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'User not found'
            });
        });
        it('should return 400 if name already exists', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const existingUser = _setup.testUtils.createMockUser({
                name: 'Existing Name'
            });
            mockUser.findById.mockResolvedValue(mockUserData);
            mockUser.findOne.mockResolvedValue(existingUser);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    name: 'Existing Name'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.editUserProfile)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'A user with the same email and name already exists.'
            });
        });
    });
    // 5. test deleteUser API
    describe('deleteUser', ()=>{
        it('should delete user successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockFamilyData = _setup.testUtils.createMockFamily({
                members: [
                    {
                        _id: '507f1f77bcf86cd799439011',
                        role: 'child',
                        name: 'Test',
                        gender: 'male',
                        avatar: '/avatar.png'
                    }
                ]
            });
            mockUser.findById.mockResolvedValue(mockUserData);
            mockFamily.findById.mockResolvedValue(mockFamilyData);
            mockUser.countDocuments.mockResolvedValue(2); // More than 1 parent
            mockUser.findByIdAndDelete.mockResolvedValue(mockUserData);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.deleteUser)(mockReq, mockRes);
            expect(mockUser.findByIdAndDelete).toHaveBeenCalledWith('507f1f77bcf86cd799439011');
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.deleteUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 400 if trying to delete last parent', async ()=>{
            const mockParent = _setup.testUtils.createMockUser({
                role: 'parent'
            });
            const mockFamilyData = _setup.testUtils.createMockFamily();
            mockUser.findById.mockResolvedValue(mockParent);
            mockFamily.findById.mockResolvedValue(mockFamilyData);
            mockUser.countDocuments.mockResolvedValue(1); // Only 1 parent
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockParent,
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.deleteUser)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Cannot delete the last parent in the family'
            });
        });
    });
    // 6. test updatePassword API
    describe('updatePassword', ()=>{
        it('should update password successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            mockUser.findById.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValueOnce(true) // Old password matches
            .mockResolvedValueOnce(false); // New password is different
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    oldPassword: 'oldPass123!',
                    newPassword: 'NewPass123!',
                    confirmPassword: 'NewPass123!'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updatePassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Password updated successfully.",
                password: 'NewPass123!'
            });
        });
        it('should return 400 if old password incorrect', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            mockUser.findById.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(false);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    oldPassword: 'wrongPass',
                    newPassword: 'NewPass123!',
                    confirmPassword: 'NewPass123!'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updatePassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Old password is incorrect.'
            });
        });
        it('should return 400 if new password same as old', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            mockUser.findById.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(true);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    oldPassword: 'samePass123!',
                    newPassword: 'samePass123!',
                    confirmPassword: 'samePass123!'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updatePassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'New password cannot be the same as the old password.'
            });
        });
        it('should return 400 if password does not meet requirements', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            mockUser.findById.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValueOnce(true) // Old password matches
            .mockResolvedValueOnce(false); // New password is different
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    userId: '507f1f77bcf86cd799439011',
                    oldPassword: 'oldPass123!',
                    newPassword: 'weak',
                    confirmPassword: 'weak'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updatePassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Password must be at least 8 characters long, include an uppercase letter, lowercase letter, a number, and a special character.'
            });
        });
    });
    // 7. test getUserStars API
    describe('getUserStars', ()=>{
        it('should get user stars successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 150
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Stars retrieved successfully",
                stars: 150
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 8. test updateUserStars API
    describe('updateUserStars', ()=>{
        it('should update user stars successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            mockFamily.findByIdAndUpdate.mockResolvedValue({});
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockUserData.stars).toBe(150); // 100 + 50
            expect(mockFamily.findByIdAndUpdate).toHaveBeenCalledWith('507f1f77bcf86cd799439012', {
                $inc: {
                    totalStars: 50
                }
            });
            expect(mockRecalculateFamilyMemberRanks.recalculateFamilyMemberRanks).toHaveBeenCalledWith('507f1f77bcf86cd799439012', mockUserData);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "User stars updated successfully",
                user: mockUserData
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 400 if stars is undefined', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {} // No stars field
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Stars must be a valid number.'
            });
        });
        it('should return 400 if stars is not a number', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 'invalid'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Stars must be a valid number.'
            });
        });
        it('should return 400 if stars is negative', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: -10
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Stars must be a valid number.'
            });
        });
        it('should return 400 if user has no family id', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: null // No family ID
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockUserData.stars).toBe(150); // Stars still get added
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'No family id'
            });
        });
        it('should handle zero stars correctly', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            mockFamily.findByIdAndUpdate.mockResolvedValue({});
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 0
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockUserData.stars).toBe(100); // 100 + 0 = 100
            expect(mockFamily.findByIdAndUpdate).toHaveBeenCalledWith('507f1f77bcf86cd799439012', {
                $inc: {
                    totalStars: 0
                }
            });
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should handle database error gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            // Mock save to throw an error
            mockUserData.save = jest.fn().mockRejectedValue(new Error('Database error'));
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error updating user stars'
            });
        });
        it('should handle family update error gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            // Mock family update to throw an error
            mockFamily.findByIdAndUpdate.mockRejectedValue(new Error('Family update failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error updating user stars'
            });
        });
        it('should handle rank recalculation error gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                stars: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            mockFamily.findByIdAndUpdate.mockResolvedValue({});
            // Mock rank recalculation to throw an error
            mockRecalculateFamilyMemberRanks.recalculateFamilyMemberRanks.mockRejectedValue(new Error('Rank calculation failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    stars: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserStars)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error updating user stars'
            });
        });
    });
    // 9. test getUserCoins API
    describe('getUserCoins', ()=>{
        it('should get user coins successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                coins: 200
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserCoins)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Coins retrieved successfully",
                coins: 200
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserCoins)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 10. test updateUserCoins API
    describe('updateUserCoins', ()=>{
        it('should update user coins successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                coins: 100
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    coins: 50
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserCoins)(mockReq, mockRes);
            expect(mockUserData.coins).toBe(150);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "User coins updated successfully",
                user: mockUserData
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserCoins)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 400 if coins is invalid', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    coins: 'invalid'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateUserCoins)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Stars must be a valid number.'
            });
        });
    });
    // 11. test getLocation API
    describe('getLocation', ()=>{
        it('should get user location successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                currentLocation: 'New York'
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getLocation)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Location retrieved successfully",
                location: 'New York'
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getLocation)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 12. test updateLocation API
    describe('updateLocation', ()=>{
        it('should update user location successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                currentLocation: 'Old Location'
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    currentLocation: 'New Location'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateLocation)(mockReq, mockRes);
            expect(mockUserData.currentLocation).toBe('New Location');
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "User location updated successfully",
                user: mockUserData
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateLocation)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 400 if location is invalid', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    currentLocation: ''
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateLocation)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Location must be valid.'
            });
        });
        it('should return 400 if location is not string', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser();
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    currentLocation: 123
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.updateLocation)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Location must be valid.'
            });
        });
    });
    // 13. test getUserRank API
    describe('getUserRank', ()=>{
        it('should get user rank successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                rankInFamily: 3
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserRank)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Rank retrieved successfully",
                Rank: 3
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserRank)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 14. test getUserInterests API
    describe('getUserInterests', ()=>{
        it('should get user interests successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                interests: [
                    'reading',
                    'sports'
                ]
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserInterests)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Interests retrieved successfully",
                Interests: [
                    'reading',
                    'sports'
                ]
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserInterests)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 15. test startAdventure API
    describe('startAdventure', ()=>{
        it('should start adventure successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: []
            });
            const mockAdventureData = _setup.testUtils.createMockAdventure();
            mockAdventure.findById.mockResolvedValue(mockAdventureData);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.startAdventure)(mockReq, mockRes);
            expect(mockAdventure.findById).toHaveBeenCalledWith('507f1f77bcf86cd799439015');
            expect(mockUserData.adventures).toHaveLength(1);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "Adventure started successfully",
                user: mockUserData
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.startAdventure)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 404 if adventure not found', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: []
            });
            mockAdventure.findById.mockResolvedValue(null);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.startAdventure)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Adventure not found'
            });
        });
        it('should return 400 if adventure already started', async ()=>{
            const existingAdventure = {
                adventureId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                challenges: [],
                status: 'in-progress',
                isAdventureCompleted: false,
                starsReward: 100,
                coinsReward: 50,
                progress: 0
            };
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: [
                    existingAdventure
                ]
            });
            const mockAdventureData = _setup.testUtils.createMockAdventure();
            mockAdventure.findById.mockResolvedValue(mockAdventureData);
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.startAdventure)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Adventure already started'
            });
        });
    });
    // 16. test completeChallenge API
    describe('completeChallenge', ()=>{
        it('should complete challenge successfully', async ()=>{
            const mockChallenge = {
                challengeId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                isCompleted: false,
                completedAt: undefined
            };
            const mockAdventureProgress = {
                adventureId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                challenges: [
                    mockChallenge
                ],
                progress: 0,
                isAdventureCompleted: false,
                status: 'in-progress',
                starsReward: 100,
                coinsReward: 50
            };
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: [
                    mockAdventureProgress
                ],
                stars: 100,
                coins: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            const mockAdventureData = {
                challenges: [
                    {
                        _id: {
                            equals: jest.fn().mockReturnValue(true)
                        },
                        starsReward: 25,
                        coinsReward: 15
                    }
                ]
            };
            mockAdventure.findById.mockReturnValue({
                lean: jest.fn().mockResolvedValue(mockAdventureData)
            });
            mockFamily.findByIdAndUpdate.mockResolvedValue({});
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015',
                    challengeId: '507f1f77bcf86cd799439016'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockChallenge.isCompleted).toBe(true);
            expect(mockChallenge.completedAt).toBeDefined();
            expect(mockUserData.stars).toBe(225);
            expect(mockUserData.coins).toBe(165);
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should complete challenge without adventure completion bonus', async ()=>{
            const mockChallenge1 = {
                challengeId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                isCompleted: false,
                completedAt: undefined
            };
            const mockChallenge2 = {
                challengeId: {
                    equals: jest.fn().mockReturnValue(false)
                },
                isCompleted: false,
                completedAt: undefined
            };
            const mockAdventureProgress = {
                adventureId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                challenges: [
                    mockChallenge1,
                    mockChallenge2
                ],
                progress: 0,
                isAdventureCompleted: false,
                status: 'in-progress',
                starsReward: 100,
                coinsReward: 50
            };
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: [
                    mockAdventureProgress
                ],
                stars: 100,
                coins: 100,
                familyId: '507f1f77bcf86cd799439012'
            });
            const mockAdventureData = {
                challenges: [
                    {
                        _id: {
                            equals: jest.fn().mockReturnValue(true)
                        },
                        starsReward: 25,
                        coinsReward: 15
                    }
                ]
            };
            mockAdventure.findById.mockReturnValue({
                lean: jest.fn().mockResolvedValue(mockAdventureData)
            });
            mockFamily.findByIdAndUpdate.mockResolvedValue({});
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015',
                    challengeId: '507f1f77bcf86cd799439016'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockChallenge1.isCompleted).toBe(true);
            expect(mockAdventureProgress.progress).toBe(50);
            expect(mockAdventureProgress.isAdventureCompleted).toBe(false);
            expect(mockUserData.stars).toBe(125);
            expect(mockUserData.coins).toBe(115);
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 404 if adventure not found in user profile', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: []
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015',
                    challengeId: '507f1f77bcf86cd799439016'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: "Adventure not found in user's profile"
            });
        });
        it('should return 404 if challenge not found in adventure', async ()=>{
            const mockAdventureProgress = {
                adventureId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                challenges: [],
                progress: 0,
                isAdventureCompleted: false,
                status: 'in-progress',
                starsReward: 100,
                coinsReward: 50
            };
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: [
                    mockAdventureProgress
                ]
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015',
                    challengeId: '507f1f77bcf86cd799439016'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Challenge not found in adventure'
            });
        });
        it('should return 404 if adventure data not found', async ()=>{
            const mockChallenge = {
                challengeId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                isCompleted: false
            };
            const mockAdventureProgress = {
                adventureId: {
                    equals: jest.fn().mockReturnValue(true)
                },
                challenges: [
                    mockChallenge
                ],
                progress: 0
            };
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: [
                    mockAdventureProgress
                ]
            });
            mockAdventure.findById.mockReturnValue({
                lean: jest.fn().mockResolvedValue(null)
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData,
                body: {
                    adventureId: '507f1f77bcf86cd799439015',
                    challengeId: '507f1f77bcf86cd799439016'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.completeChallenge)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Adventure not found'
            });
        });
    });
    // 17. test getUserAdventures API
    describe('getUserAdventures', ()=>{
        it('should get user adventures successfully', async ()=>{
            const mockAdventures = [
                {
                    adventureId: '507f1f77bcf86cd799439015',
                    status: 'in-progress'
                }
            ];
            const mockUserData = _setup.testUtils.createMockUser({
                adventures: mockAdventures
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAdventures)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: "User adventures retrieved successfully",
                Adventure: mockAdventures
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAdventures)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
    });
    // 18. test getUserPurchasedItems API
    describe('getUserPurchasedItems', ()=>{
        it('should get user purchased items successfully', async ()=>{
            const mockPurchasedItems = [
                {
                    itemId: '507f1f77bcf86cd799439020'
                },
                {
                    itemId: '507f1f77bcf86cd799439021'
                }
            ];
            const mockUserData = {
                purchasedItems: mockPurchasedItems
            };
            const mockUserDoc = {
                select: jest.fn().mockResolvedValue(mockUserData)
            };
            mockUser.findById.mockReturnValue(mockUserDoc);
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser(),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserPurchasedItems)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                message: "Purchased items retrieved successfully",
                purchasedItems: [
                    '507f1f77bcf86cd799439020',
                    '507f1f77bcf86cd799439021'
                ]
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserPurchasedItems)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Unauthorized'
            });
        });
        it('should return 403 if trying to access other user items', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser({
                    _id: 'different-user-id'
                }),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserPurchasedItems)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(403);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Forbidden'
            });
        });
        it('should return 404 if user not found', async ()=>{
            const mockUserDoc = {
                select: jest.fn().mockResolvedValue(null)
            };
            mockUser.findById.mockReturnValue(mockUserDoc);
            const mockReq = _setup.testUtils.createMockRequest({
                user: _setup.testUtils.createMockUser(),
                body: {
                    userId: '507f1f77bcf86cd799439011'
                }
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserPurchasedItems)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'User not found'
            });
        });
    });
    describe('getUserAvatar', ()=>{
        it('should get user avatar successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                avatar: '/avatars/child-boy-1.png'
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                message: "Avatar retrieved successfully",
                avatar: '/avatars/child-boy-1.png'
            });
        });
        it('should return 401 if user not authenticated', async ()=>{
            const mockReq = _setup.testUtils.createMockRequest({
                user: null
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: "Unauthorized"
            });
        });
        it('should handle different avatar formats correctly', async ()=>{
            const testCases = [
                {
                    avatar: '/avatars/parent-woman.png',
                    description: 'parent avatar'
                },
                {
                    avatar: '/avatars/child-girl-2.png',
                    description: 'child avatar'
                },
                {
                    avatar: 'https://example.com/avatar.jpg',
                    description: 'external URL'
                },
                {
                    avatar: '/default-avatar.svg',
                    description: 'default avatar'
                },
                {
                    avatar: '',
                    description: 'empty string'
                },
                {
                    avatar: null,
                    description: 'null avatar'
                },
                {
                    avatar: undefined,
                    description: 'undefined avatar'
                }
            ];
            for (const { avatar, description } of testCases){
                const mockUserData = _setup.testUtils.createMockUser({
                    avatar
                });
                const mockReq = _setup.testUtils.createMockRequest({
                    user: mockUserData
                });
                const mockRes = _setup.testUtils.createMockResponse();
                await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
                expect(mockRes.status).toHaveBeenCalledWith(200);
                expect(mockRes.json).toHaveBeenCalledWith({
                    message: "Avatar retrieved successfully",
                    avatar: avatar
                });
            }
        });
        it('should handle server errors gracefully', async ()=>{
            // Create a normal user object first
            const mockUserData = _setup.testUtils.createMockUser();
            // Then override the avatar property with a getter that throws
            Object.defineProperty(mockUserData, 'avatar', {
                get () {
                    throw new Error('Database connection failed');
                },
                configurable: true
            });
            const mockReq = _setup.testUtils.createMockRequest({
                user: mockUserData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: "Error fetching avatar"
            });
        });
        it('should handle user with all avatar edge cases', async ()=>{
            // Test various edge cases for avatar property
            const edgeCases = [
                {
                    avatar: 0,
                    description: 'number zero'
                },
                {
                    avatar: false,
                    description: 'boolean false'
                },
                {
                    avatar: [],
                    description: 'empty array'
                },
                {
                    avatar: {},
                    description: 'empty object'
                },
                {
                    avatar: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
                    description: 'base64 image'
                }
            ];
            for (const { avatar, description } of edgeCases){
                const mockUserData = _setup.testUtils.createMockUser({
                    avatar
                });
                const mockReq = _setup.testUtils.createMockRequest({
                    user: mockUserData
                });
                const mockRes = _setup.testUtils.createMockResponse();
                await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
                expect(mockRes.status).toHaveBeenCalledWith(200);
                expect(mockRes.json).toHaveBeenCalledWith({
                    message: "Avatar retrieved successfully",
                    avatar: avatar
                });
            }
        });
        it('should handle user object without avatar property', async ()=>{
            // Create user without avatar property
            const userWithoutAvatar = _setup.testUtils.createMockUser();
            delete userWithoutAvatar.avatar;
            const mockReq = _setup.testUtils.createMockRequest({
                user: userWithoutAvatar
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                message: "Avatar retrieved successfully",
                avatar: undefined
            });
        });
        it('should work with minimal user object', async ()=>{
            // Test with very basic user object
            const minimalUser = {
                _id: '507f1f77bcf86cd799439011',
                avatar: '/simple-avatar.png'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                user: minimalUser
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _usercontroller.getUserAvatar)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                message: "Avatar retrieved successfully",
                avatar: '/simple-avatar.png'
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNFUlxcRGVza3RvcFxcZ3VhcmRpYW4tZ3JvdmVcXGd1YXJkaWFuLWdyb3ZlLWJhY2tlbmRcXHRlc3RzXFxjb250cm9sbGVyc1xcdXNlci5jb250cm9sbGVyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGVzdFV0aWxzIH0gZnJvbSAnLi4vc2V0dXAnO1xyXG5pbXBvcnQgeyAgZ2V0VXNlcnMsIGdldFVzZXJCeUlkLCBjcmVhdGVVc2VyLCBlZGl0VXNlclByb2ZpbGUsXHJcbiAgICBkZWxldGVVc2VyLCB1cGRhdGVQYXNzd29yZCwgZ2V0VXNlclN0YXJzLCB1cGRhdGVVc2VyU3RhcnMsXHJcbiAgICBnZXRVc2VyQ29pbnMsIHVwZGF0ZVVzZXJDb2lucywgZ2V0TG9jYXRpb24sIHVwZGF0ZUxvY2F0aW9uLFxyXG4gICAgZ2V0VXNlclJhbmssIGdldFVzZXJJbnRlcmVzdHMsIHN0YXJ0QWR2ZW50dXJlLCBjb21wbGV0ZUNoYWxsZW5nZSxcclxuICAgIGdldFVzZXJBZHZlbnR1cmVzLCBnZXRVc2VyUHVyY2hhc2VkSXRlbXMsIGdldFVzZXJBdmF0YXJcclxufSBmcm9tICcuLi8uLi9zcmMvY29udHJvbGxlcnMvdXNlci5jb250cm9sbGVyJztcclxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uLy4uL3NyYy9tb2RlbHMvdXNlci5tb2RlbCc7XHJcbmltcG9ydCAqIGFzIGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQgZnJvbSAnLi4vLi4vc3JjL3V0aWxzL2dlbmVyYXRlU2VjdXJlUGFzc3dvcmQnO1xyXG5pbXBvcnQgKiBhcyBjaGVja0lkIGZyb20gJy4uLy4uL3NyYy91dGlscy9jaGVja0lkJztcclxuaW1wb3J0IHsgQWR2ZW50dXJlIH0gZnJvbSAnLi4vLi4vc3JjL21vZGVscy9hZHZlbnR1cmUubW9kZWwnO1xyXG5pbXBvcnQgeyBGYW1pbHkgfSBmcm9tICcuLi8uLi9zcmMvbW9kZWxzL2ZhbWlseS5tb2RlbCc7XHJcbmltcG9ydCAqIGFzIGVtYWlsU2VydmljZSBmcm9tICcuLi8uLi9zcmMvc2VydmljZXMvZW1haWwuc2VydmljZSc7XHJcbmltcG9ydCAqIGFzIHJlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MgZnJvbSAnLi4vLi4vc3JjL3V0aWxzL3JlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MnO1xyXG5pbXBvcnQgKiBhcyBiY3J5cHQgZnJvbSAnYmNyeXB0JztcclxuXHJcbi8vIE1vY2sgYWxsIGRlcGVuZGVuY2llc1xyXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9tb2RlbHMvdXNlci5tb2RlbCcpO1xyXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9tb2RlbHMvYWR2ZW50dXJlLm1vZGVsJyk7XHJcbmplc3QubW9jaygnLi4vLi4vc3JjL21vZGVscy9mYW1pbHkubW9kZWwnKTtcclxuamVzdC5tb2NrKCcuLi8uLi9zcmMvc2VydmljZXMvZW1haWwuc2VydmljZScpO1xyXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy91dGlscy9nZW5lcmF0ZVNlY3VyZVBhc3N3b3JkJyk7XHJcbmplc3QubW9jaygnLi4vLi4vc3JjL3V0aWxzL3JlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MnKTtcclxuamVzdC5tb2NrKCcuLi8uLi9zcmMvdXRpbHMvY2hlY2tJZCcpO1xyXG5qZXN0Lm1vY2soJ2JjcnlwdCcpO1xyXG5cclxuY29uc3QgbW9ja1VzZXIgPSBVc2VyIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBVc2VyPjtcclxuY29uc3QgbW9ja0FkdmVudHVyZSA9IEFkdmVudHVyZSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgQWR2ZW50dXJlPjtcclxuY29uc3QgbW9ja0ZhbWlseSA9IEZhbWlseSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgRmFtaWx5PjtcclxuY29uc3QgbW9ja0dlbmVyYXRlU2VjdXJlUGFzc3dvcmQgPSBnZW5lcmF0ZVNlY3VyZVBhc3N3b3JkIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBnZW5lcmF0ZVNlY3VyZVBhc3N3b3JkPjtcclxuY29uc3QgbW9ja0NoZWNrSWQgPSBjaGVja0lkIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBjaGVja0lkPjtcclxuY29uc3QgbW9ja0VtYWlsU2VydmljZSA9IGVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZW1haWxTZXJ2aWNlPjtcclxuY29uc3QgbW9ja1JlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MgPSByZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzIGFzIGplc3QuTW9ja2VkPHR5cGVvZiByZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzPjtcclxuY29uc3QgbW9ja0JjcnlwdCA9IGJjcnlwdCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgYmNyeXB0PjtcclxuXHJcbmRlc2NyaWJlKCdVc2VyIENvbnRyb2xsZXIgVGVzdHMnLCAoKSA9PiB7XHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXR1cCBVc2VyIG1vZGVsIG1ldGhvZHNcclxuICAgICAgICBtb2NrVXNlci5maW5kID0gamVzdC5mbigpO1xyXG4gICAgICAgIG1vY2tVc2VyLmZpbmRPbmUgPSBqZXN0LmZuKCk7XHJcbiAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWQgPSBqZXN0LmZuKCk7XHJcbiAgICAgICAgbW9ja1VzZXIuY3JlYXRlID0gamVzdC5mbigpO1xyXG4gICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkQW5kVXBkYXRlID0gamVzdC5mbigpO1xyXG4gICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkQW5kRGVsZXRlID0gamVzdC5mbigpO1xyXG4gICAgICAgIG1vY2tVc2VyLmNvdW50RG9jdW1lbnRzID0gamVzdC5mbigpO1xyXG5cclxuICAgICAgICAvLyBTZXR1cCBBZHZlbnR1cmUgbW9kZWwgbWV0aG9kc1xyXG4gICAgICAgIG1vY2tBZHZlbnR1cmUuZmluZEJ5SWQgPSBqZXN0LmZuKCk7XHJcblxyXG4gICAgICAgIC8vIFNldHVwIEZhbWlseSBtb2RlbCBtZXRob2RzXHJcbiAgICAgICAgbW9ja0ZhbWlseS5maW5kT25lID0gamVzdC5mbigpO1xyXG4gICAgICAgIG1vY2tGYW1pbHkuZmluZEJ5SWQgPSBqZXN0LmZuKCk7XHJcbiAgICAgICAgbW9ja0ZhbWlseS5maW5kQnlJZEFuZFVwZGF0ZSA9IGplc3QuZm4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXR1cCB1dGlsaXR5IG1vY2tzXHJcbiAgICAgICAgbW9ja0dlbmVyYXRlU2VjdXJlUGFzc3dvcmQuZ2VuZXJhdGVTZWN1cmVQYXNzd29yZC5tb2NrUmV0dXJuVmFsdWUoJ1RlbXBQYXNzMTIzIScpO1xyXG4gICAgICAgIG1vY2tDaGVja0lkLmNoZWNrSWQubW9ja1JldHVyblZhbHVlKHRydWUpO1xyXG4gICAgICAgIGplc3Quc3B5T24obW9ja0VtYWlsU2VydmljZSwgJ3NlbmRNYWlsJykubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuICAgICAgICBqZXN0LnNweU9uKG1vY2tSZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzLCAncmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcycpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgKGplc3Quc3B5T24oYmNyeXB0LCAnaGFzaCcpIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoJ2hhc2hlZFBhc3N3b3JkJyk7XHJcbiAgICAgICAgKGplc3Quc3B5T24oYmNyeXB0LCAnY29tcGFyZScpIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAxLiB0ZXN0IGdldFVzZXJzIEFQSVxyXG4gICAgZGVzY3JpYmUoJ2dldFVzZXJzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFsbCB1c2VycyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VycyA9IFtcclxuICAgICAgICAgICAgICAgIHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IG5hbWU6ICdKb2huJyB9KSxcclxuICAgICAgICAgICAgICAgIHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IG5hbWU6ICdKYW5lJywgX2lkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDEzJyB9KVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VycyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0VXNlcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlci5maW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2Vycyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnRXJyb3IgcmV0cmlldmluZyB1c2VycycgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyLiB0ZXN0IGdldFVzZXJCeUlkIEFQSVxyXG4gICAgZGVzY3JpYmUoJ2dldFVzZXJCeUlkJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHVzZXIgYnkgSUQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlcl9kYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRG9jID0ge1xyXG4gICAgICAgICAgICAgICAgLi4ubW9ja1VzZXJfZGF0YSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyX2RhdGEpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXR1cm5WYWx1ZShtb2NrVXNlckRvYyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCksXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJCeUlkKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmV0cmlldmluZyB1c2VyIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJfZGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0VXNlckJ5SWQobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCBpZiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEb2MgPSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kQnlJZC5tb2NrUmV0dXJuVmFsdWUobW9ja1VzZXJEb2MgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyQnlJZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDQpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVXNlciBub3QgZm91bmQnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDMgaWYgZm9yYmlkZGVuIGFjY2VzcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJfZGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGVtYWlsOiAnZGlmZmVyZW50QGVtYWlsLmNvbScgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRG9jID0ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJfZGF0YSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWQubW9ja1JldHVyblZhbHVlKG1vY2tVc2VyRG9jIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyBfaWQ6ICdkaWZmZXJlbnQtaWQnLCByb2xlOiAnY2hpbGQnIH0pLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyQnlJZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDMpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnRm9yYmlkZGVuJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDMuIHRlc3QgY3JlYXRlVXNlciBBUElcclxuICAgIGRlc2NyaWJlKCdjcmVhdGVVc2VyJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkVXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IENoaWxkJyxcclxuICAgICAgICAgICAgYmlydGhkYXk6ICcyMDEwLTAxLTAxJyxcclxuICAgICAgICAgICAgZ2VuZGVyOiAnbWFsZScsXHJcbiAgICAgICAgICAgIHJvbGU6ICdjaGlsZCcsXHJcbiAgICAgICAgICAgIGF2YXRhcjogJy9hdmF0YXIucG5nJyxcclxuICAgICAgICAgICAgaW50ZXJlc3RzOiBbJ3JlYWRpbmcnLCAnc3BvcnRzJ11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSB1c2VyIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1BhcmVudCA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJvbGU6ICdwYXJlbnQnLCBlbWFpbDogJ3BhcmVudEB0ZXN0LmNvbScgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGYW1pbHlEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tGYW1pbHkoeyBlbWFpbDogJ3BhcmVudEB0ZXN0LmNvbScsIG1lbWJlcnM6IFtdIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrQ3JlYXRlZFVzZXIgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIodmFsaWRVc2VyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBObyBleGlzdGluZyB1c2VyXHJcbiAgICAgICAgICAgIG1vY2tGYW1pbHkuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRmFtaWx5RGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBtb2NrVXNlci5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NyZWF0ZWRVc2VyIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrUGFyZW50LFxyXG4gICAgICAgICAgICAgICAgYm9keTogdmFsaWRVc2VyRGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlci5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tFbWFpbFNlcnZpY2Uuc2VuZE1haWwpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG51bGwsIGJvZHk6IHZhbGlkVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVVc2VyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDMgaWYgdXNlciBpcyBjaGlsZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NoaWxkID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgcm9sZTogJ2NoaWxkJyB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tDaGlsZCwgYm9keTogdmFsaWRVc2VyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAzKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0ZvcmJpZGRlbicgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiByZXF1aXJlZCBmaWVsZHMgbWlzc2luZycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1BhcmVudCA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJvbGU6ICdwYXJlbnQnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBpbmNvbXBsZXRlRGF0YSA9IHsgbmFtZTogJ1Rlc3QnIH07IC8vIE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzXHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbW9ja1BhcmVudCwgYm9keTogaW5jb21wbGV0ZURhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVVc2VyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdBbGwgcmVxdWlyZWQgZmllbGRzIG11c3QgYmUgZmlsbGVkLicgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwOSBpZiB1c2VybmFtZSBhbHJlYWR5IHRha2VuJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUGFyZW50ID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgcm9sZTogJ3BhcmVudCcsIGVtYWlsOiAncGFyZW50QHRlc3QuY29tJyB9KTtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVc2VyID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgbmFtZTogJ1Rlc3QgQ2hpbGQnLCBlbWFpbDogJ3BhcmVudEB0ZXN0LmNvbScgfSk7XHJcblxyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nVXNlciBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tQYXJlbnQsIGJvZHk6IHZhbGlkVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVVc2VyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwOSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdUaGlzIHVzZXJuYW1lIGlzIGFscmVhZHkgdGFrZW4gZm9yIHRoaXMgZW1haWwuJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIGludGVyZXN0cyBpcyBub3QgYXJyYXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tQYXJlbnQgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyByb2xlOiAncGFyZW50JyB9KTtcclxuICAgICAgICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7IC4uLnZhbGlkVXNlckRhdGEsIGludGVyZXN0czogJ25vdC1hbi1hcnJheScgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrUGFyZW50LCBib2R5OiBpbnZhbGlkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0ludGVyZXN0cyBtdXN0IGJlIGFuIGFycmF5LicgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBpbnZhbGlkIGdlbmRlcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1BhcmVudCA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJvbGU6ICdwYXJlbnQnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHsgLi4udmFsaWRVc2VyRGF0YSwgZ2VuZGVyOiAnaW52YWxpZCcgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrUGFyZW50LCBib2R5OiBpbnZhbGlkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogXCJHZW5kZXIgbXVzdCBiZSBlaXRoZXIgJ21hbGUnIG9yICdmZW1hbGUnLlwiIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgaW52YWxpZCByb2xlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUGFyZW50ID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgcm9sZTogJ3BhcmVudCcgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyAuLi52YWxpZFVzZXJEYXRhLCByb2xlOiAnaW52YWxpZCcgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrUGFyZW50LCBib2R5OiBpbnZhbGlkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0ludmFsaWQgcm9sZS4nIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgaW52YWxpZCBiaXJ0aGRheScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1BhcmVudCA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJvbGU6ICdwYXJlbnQnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHsgLi4udmFsaWRVc2VyRGF0YSwgYmlydGhkYXk6ICdpbnZhbGlkLWRhdGUnIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbW9ja1BhcmVudCwgYm9keTogaW52YWxpZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVVc2VyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdJbnZhbGlkIGJpcnRoZGF5IGZvcm1hdC4nIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDQgaWYgZmFtaWx5IG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1BhcmVudCA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJvbGU6ICdwYXJlbnQnIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gTm8gZXhpc3RpbmcgdXNlclxyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vIGZhbWlseSBmb3VuZFxyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tQYXJlbnQsIGJvZHk6IHZhbGlkVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVVc2VyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwNCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdGYW1pbHkgbm90IGZvdW5kLicgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gNC4gdGVzdCBlZGl0VXNlclByb2ZpbGUgQVBJXHJcbiAgICBkZXNjcmliZSgnZWRpdFVzZXJQcm9maWxlJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgZWRpdCB1c2VyIHByb2ZpbGUgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vIGR1cGxpY2F0ZSBuYW1lXHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VwZGF0ZWQgTmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgYmlydGhkYXk6ICcxOTkwLTAxLTAxJyxcclxuICAgICAgICAgICAgICAgICAgICBnZW5kZXI6ICdtYWxlJyxcclxuICAgICAgICAgICAgICAgICAgICBhdmF0YXI6ICcvbmV3LWF2YXRhci5wbmcnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZWRpdFVzZXJQcm9maWxlKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVXNlciBwcm9maWxlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBleHBlY3QuYW55KE9iamVjdClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMSBpZiB1c2VyIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbnVsbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGVkaXRVc2VyUHJvZmlsZShtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAzIGlmIGNoaWxkIHRyaWVzIHRvIGNoYW5nZSByb2xlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrQ2hpbGQgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyByb2xlOiAnY2hpbGQnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrQ2hpbGQsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHJvbGU6ICdwYXJlbnQnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBlZGl0VXNlclByb2ZpbGUobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAzKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0ZvcmJpZGRlbjogWW91IGNhbm5vdCBjaGFuZ2Ugcm9sZSBub3IgZW1haWwnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDQgaWYgdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tQYXJlbnQgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyByb2xlOiAncGFyZW50JyB9KTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrUGFyZW50LFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBlZGl0VXNlclByb2ZpbGUobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VzZXIgbm90IGZvdW5kJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIG5hbWUgYWxyZWFkeSBleGlzdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1VzZXIgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyBuYW1lOiAnRXhpc3RpbmcgTmFtZScgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ1VzZXIgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRXhpc3RpbmcgTmFtZSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBlZGl0VXNlclByb2ZpbGUobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnQSB1c2VyIHdpdGggdGhlIHNhbWUgZW1haWwgYW5kIG5hbWUgYWxyZWFkeSBleGlzdHMuJyBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA1LiB0ZXN0IGRlbGV0ZVVzZXIgQVBJXHJcbiAgICBkZXNjcmliZSgnZGVsZXRlVXNlcicsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSB1c2VyIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGYW1pbHlEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tGYW1pbHkoeyBcclxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IFt7IF9pZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScsIHJvbGU6ICdjaGlsZCcsIG5hbWU6ICdUZXN0JywgZ2VuZGVyOiAnbWFsZScsIGF2YXRhcjogJy9hdmF0YXIucG5nJyB9XVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyRGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tGYW1pbHlEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmNvdW50RG9jdW1lbnRzLm1vY2tSZXNvbHZlZFZhbHVlKDIpOyAvLyBNb3JlIHRoYW4gMSBwYXJlbnRcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWRBbmREZWxldGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGRlbGV0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlci5maW5kQnlJZEFuZERlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMSBpZiB1c2VyIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbnVsbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGRlbGV0ZVVzZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiB0cnlpbmcgdG8gZGVsZXRlIGxhc3QgcGFyZW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUGFyZW50ID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgcm9sZTogJ3BhcmVudCcgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGYW1pbHlEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tGYW1pbHkoKTtcclxuXHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQYXJlbnQgYXMgYW55KTtcclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRmFtaWx5RGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBtb2NrVXNlci5jb3VudERvY3VtZW50cy5tb2NrUmVzb2x2ZWRWYWx1ZSgxKTsgLy8gT25seSAxIHBhcmVudFxyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1BhcmVudCxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgdXNlcklkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZGVsZXRlVXNlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDYW5ub3QgZGVsZXRlIHRoZSBsYXN0IHBhcmVudCBpbiB0aGUgZmFtaWx5JyBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA2LiB0ZXN0IHVwZGF0ZVBhc3N3b3JkIEFQSVxyXG4gICAgZGVzY3JpYmUoJ3VwZGF0ZVBhc3N3b3JkJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHBhc3N3b3JkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyRGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgKG1vY2tCY3J5cHQuY29tcGFyZSBhcyBqZXN0Lk1vY2spXHJcbiAgICAgICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHRydWUpICAgLy8gT2xkIHBhc3N3b3JkIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoZmFsc2UpOyAvLyBOZXcgcGFzc3dvcmQgaXMgZGlmZmVyZW50XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFzc3dvcmQ6ICdvbGRQYXNzMTIzIScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFzc3dvcmQ6ICdOZXdQYXNzMTIzIScsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybVBhc3N3b3JkOiAnTmV3UGFzczEyMyEnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUGFzc3dvcmQobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJQYXNzd29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseS5cIixcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAnTmV3UGFzczEyMyEnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgb2xkIHBhc3N3b3JkIGluY29ycmVjdCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyRGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICAobW9ja0JjcnlwdC5jb21wYXJlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBcclxuICAgICAgICAgICAgICAgICAgICB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhc3N3b3JkOiAnd3JvbmdQYXNzJyxcclxuICAgICAgICAgICAgICAgICAgICBuZXdQYXNzd29yZDogJ05ld1Bhc3MxMjMhJyxcclxuICAgICAgICAgICAgICAgICAgICBjb25maXJtUGFzc3dvcmQ6ICdOZXdQYXNzMTIzISdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVQYXNzd29yZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnT2xkIHBhc3N3b3JkIGlzIGluY29ycmVjdC4nIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgbmV3IHBhc3N3b3JkIHNhbWUgYXMgb2xkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIChtb2NrQmNyeXB0LmNvbXBhcmUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyxcclxuICAgICAgICAgICAgICAgICAgICBvbGRQYXNzd29yZDogJ3NhbWVQYXNzMTIzIScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFzc3dvcmQ6ICdzYW1lUGFzczEyMyEnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1QYXNzd29yZDogJ3NhbWVQYXNzMTIzISdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVQYXNzd29yZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdOZXcgcGFzc3dvcmQgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBvbGQgcGFzc3dvcmQuJyBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHJlcXVpcmVtZW50cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyRGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgKG1vY2tCY3J5cHQuY29tcGFyZSBhcyBqZXN0Lk1vY2spXHJcbiAgICAgICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHRydWUpICAgLy8gT2xkIHBhc3N3b3JkIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoZmFsc2UpOyAvLyBOZXcgcGFzc3dvcmQgaXMgZGlmZmVyZW50XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFzc3dvcmQ6ICdvbGRQYXNzMTIzIScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFzc3dvcmQ6ICd3ZWFrJywgLy8gV2VhayBwYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1QYXNzd29yZDogJ3dlYWsnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUGFzc3dvcmQobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMgbG9uZywgaW5jbHVkZSBhbiB1cHBlcmNhc2UgbGV0dGVyLCBsb3dlcmNhc2UgbGV0dGVyLCBhIG51bWJlciwgYW5kIGEgc3BlY2lhbCBjaGFyYWN0ZXIuJyBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA3LiB0ZXN0IGdldFVzZXJTdGFycyBBUElcclxuICAgIGRlc2NyaWJlKCdnZXRVc2VyU3RhcnMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBnZXQgdXNlciBzdGFycyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHN0YXJzOiAxNTAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJTdGFycyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBzdGFyczogMTUwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG51bGwgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA4LiB0ZXN0IHVwZGF0ZVVzZXJTdGFycyBBUElcclxuICAgIGRlc2NyaWJlKCd1cGRhdGVVc2VyU3RhcnMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgdXNlciBzdGFycyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IFxyXG4gICAgICAgICAgICAgICAgc3RhcnM6IDEwMCwgXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMicgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHt9IGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHN0YXJzOiA1MCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlVXNlclN0YXJzKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXJEYXRhLnN0YXJzKS50b0JlKDE1MCk7IC8vIDEwMCArIDUwXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICAgICAgICAgICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTInLFxyXG4gICAgICAgICAgICAgICAgeyAkaW5jOiB7IHRvdGFsU3RhcnM6IDUwIH0gfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1JlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MucmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgICAgICAgICAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDEyJyxcclxuICAgICAgICAgICAgICAgIG1vY2tVc2VyRGF0YVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVXNlciBzdGFycyB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgc3RhcnM6IDUwIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBzdGFycyBpcyB1bmRlZmluZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7fSAvLyBObyBzdGFycyBmaWVsZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVVzZXJTdGFycyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnU3RhcnMgbXVzdCBiZSBhIHZhbGlkIG51bWJlci4nIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgc3RhcnMgaXMgbm90IGEgbnVtYmVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBzdGFyczogJ2ludmFsaWQnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1N0YXJzIG11c3QgYmUgYSB2YWxpZCBudW1iZXIuJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIHN0YXJzIGlzIG5lZ2F0aXZlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBzdGFyczogLTEwIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1N0YXJzIG11c3QgYmUgYSB2YWxpZCBudW1iZXIuJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIHVzZXIgaGFzIG5vIGZhbWlseSBpZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgXHJcbiAgICAgICAgICAgICAgICBzdGFyczogMTAwLFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5SWQ6IG51bGwgLy8gTm8gZmFtaWx5IElEXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBzdGFyczogNTAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVVzZXJTdGFycyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5zdGFycykudG9CZSgxNTApOyAvLyBTdGFycyBzdGlsbCBnZXQgYWRkZWRcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnTm8gZmFtaWx5IGlkJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgemVybyBzdGFycyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IFxyXG4gICAgICAgICAgICAgICAgc3RhcnM6IDEwMCwgXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMicgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHt9IGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHN0YXJzOiAwIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlckRhdGEuc3RhcnMpLnRvQmUoMTAwKTsgLy8gMTAwICsgMCA9IDEwMFxyXG4gICAgICAgICAgICBleHBlY3QobW9ja0ZhbWlseS5maW5kQnlJZEFuZFVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgICAgICAgICAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDEyJyxcclxuICAgICAgICAgICAgICAgIHsgJGluYzogeyB0b3RhbFN0YXJzOiAwIH0gfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9yIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IFxyXG4gICAgICAgICAgICAgICAgc3RhcnM6IDEwMCwgXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMicgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBNb2NrIHNhdmUgdG8gdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgbW9ja1VzZXJEYXRhLnNhdmUgPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgc3RhcnM6IDUwIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyU3RhcnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNTAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0Vycm9yIHVwZGF0aW5nIHVzZXIgc3RhcnMnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBmYW1pbHkgdXBkYXRlIGVycm9yIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IFxyXG4gICAgICAgICAgICAgICAgc3RhcnM6IDEwMCwgXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMicgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBNb2NrIGZhbWlseSB1cGRhdGUgdG8gdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kQnlJZEFuZFVwZGF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0ZhbWlseSB1cGRhdGUgZmFpbGVkJykpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBzdGFyczogNTAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVVzZXJTdGFycyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnRXJyb3IgdXBkYXRpbmcgdXNlciBzdGFycycgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhbmsgcmVjYWxjdWxhdGlvbiBlcnJvciBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyBcclxuICAgICAgICAgICAgICAgIHN0YXJzOiAxMDAsIFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5SWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTInIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kQnlJZEFuZFVwZGF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7fSBhcyBhbnkpO1xyXG4gICAgICAgICAgICAvLyBNb2NrIHJhbmsgcmVjYWxjdWxhdGlvbiB0byB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgICAgICBtb2NrUmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcy5yZWNhbGN1bGF0ZUZhbWlseU1lbWJlclJhbmtzLm1vY2tSZWplY3RlZFZhbHVlKFxyXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdSYW5rIGNhbGN1bGF0aW9uIGZhaWxlZCcpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHN0YXJzOiA1MCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlVXNlclN0YXJzKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdFcnJvciB1cGRhdGluZyB1c2VyIHN0YXJzJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDkuIHRlc3QgZ2V0VXNlckNvaW5zIEFQSVxyXG4gICAgZGVzY3JpYmUoJ2dldFVzZXJDb2lucycsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIGdldCB1c2VyIGNvaW5zIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgY29pbnM6IDIwMCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tVc2VyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJDb2lucyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNvaW5zIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIixcclxuICAgICAgICAgICAgICAgIGNvaW5zOiAyMDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMSBpZiB1c2VyIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbnVsbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJDb2lucyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDEwLiB0ZXN0IHVwZGF0ZVVzZXJDb2lucyBBUElcclxuICAgIGRlc2NyaWJlKCd1cGRhdGVVc2VyQ29pbnMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgdXNlciBjb2lucyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGNvaW5zOiAxMDAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgY29pbnM6IDUwIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVVc2VyQ29pbnMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlckRhdGEuY29pbnMpLnRvQmUoMTUwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVzZXIgY29pbnMgdXBkYXRlZCBzdWNjZXNzZnVsbHlcIixcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlVXNlckNvaW5zKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgY29pbnMgaXMgaW52YWxpZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgY29pbnM6ICdpbnZhbGlkJyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlVXNlckNvaW5zKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdTdGFycyBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyLicgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAxMS4gdGVzdCBnZXRMb2NhdGlvbiBBUElcclxuICAgIGRlc2NyaWJlKCdnZXRMb2NhdGlvbicsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIGdldCB1c2VyIGxvY2F0aW9uIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgY3VycmVudExvY2F0aW9uOiAnTmV3IFlvcmsnIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbW9ja1VzZXJEYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0TG9jYXRpb24obW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJMb2NhdGlvbiByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ05ldyBZb3JrJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0TG9jYXRpb24obW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAxMi4gdGVzdCB1cGRhdGVMb2NhdGlvbiBBUElcclxuICAgIGRlc2NyaWJlKCd1cGRhdGVMb2NhdGlvbicsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSB1c2VyIGxvY2F0aW9uIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgY3VycmVudExvY2F0aW9uOiAnT2xkIExvY2F0aW9uJyB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBjdXJyZW50TG9jYXRpb246ICdOZXcgTG9jYXRpb24nIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVMb2NhdGlvbihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5jdXJyZW50TG9jYXRpb24pLnRvQmUoJ05ldyBMb2NhdGlvbicpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVXNlciBsb2NhdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG51bGwgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVMb2NhdGlvbihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIGxvY2F0aW9uIGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IGN1cnJlbnRMb2NhdGlvbjogJycgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUxvY2F0aW9uKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdMb2NhdGlvbiBtdXN0IGJlIHZhbGlkLicgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBsb2NhdGlvbiBpcyBub3Qgc3RyaW5nJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBjdXJyZW50TG9jYXRpb246IDEyMyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlTG9jYXRpb24obW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0xvY2F0aW9uIG11c3QgYmUgdmFsaWQuJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDEzLiB0ZXN0IGdldFVzZXJSYW5rIEFQSVxyXG4gICAgZGVzY3JpYmUoJ2dldFVzZXJSYW5rJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgZ2V0IHVzZXIgcmFuayBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IHJhbmtJbkZhbWlseTogMyB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tVc2VyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJSYW5rKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmFuayByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBSYW5rOiAzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG51bGwgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyUmFuayhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDE0LiB0ZXN0IGdldFVzZXJJbnRlcmVzdHMgQVBJXHJcbiAgICBkZXNjcmliZSgnZ2V0VXNlckludGVyZXN0cycsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIGdldCB1c2VyIGludGVyZXN0cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGludGVyZXN0czogWydyZWFkaW5nJywgJ3Nwb3J0cyddIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbW9ja1VzZXJEYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0VXNlckludGVyZXN0cyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludGVyZXN0cyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBJbnRlcmVzdHM6IFsncmVhZGluZycsICdzcG9ydHMnXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0VXNlckludGVyZXN0cyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDE1LiB0ZXN0IHN0YXJ0QWR2ZW50dXJlIEFQSVxyXG4gICAgZGVzY3JpYmUoJ3N0YXJ0QWR2ZW50dXJlJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgc3RhcnQgYWR2ZW50dXJlIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgYWR2ZW50dXJlczogW10gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tBZHZlbnR1cmVEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tBZHZlbnR1cmUoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG1vY2tBZHZlbnR1cmUuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0FkdmVudHVyZURhdGEgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgYWR2ZW50dXJlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTUnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBzdGFydEFkdmVudHVyZShtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tBZHZlbnR1cmUuZmluZEJ5SWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTUnKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5hZHZlbnR1cmVzKS50b0hhdmVMZW5ndGgoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBZHZlbnR1cmUgc3RhcnRlZCBzdWNjZXNzZnVsbHlcIixcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgc3RhcnRBZHZlbnR1cmUobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCBpZiBhZHZlbnR1cmUgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoeyBhZHZlbnR1cmVzOiBbXSB9KTtcclxuICAgICAgICAgICAgbW9ja0FkdmVudHVyZS5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgYWR2ZW50dXJlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTUnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBzdGFydEFkdmVudHVyZShtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDQpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnQWR2ZW50dXJlIG5vdCBmb3VuZCcgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBhZHZlbnR1cmUgYWxyZWFkeSBzdGFydGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0FkdmVudHVyZSA9IHtcclxuICAgICAgICAgICAgICAgIGFkdmVudHVyZUlkOiB7IGVxdWFsczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSB9LFxyXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlczogW10sXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdpbi1wcm9ncmVzcycsXHJcbiAgICAgICAgICAgICAgICBpc0FkdmVudHVyZUNvbXBsZXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdGFyc1Jld2FyZDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29pbnNSZXdhcmQ6IDUwLFxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgYWR2ZW50dXJlczogW2V4aXN0aW5nQWR2ZW50dXJlXSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0FkdmVudHVyZURhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja0FkdmVudHVyZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbW9ja0FkdmVudHVyZS5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQWR2ZW50dXJlRGF0YSBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBhZHZlbnR1cmVJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxNScgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHN0YXJ0QWR2ZW50dXJlKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdBZHZlbnR1cmUgYWxyZWFkeSBzdGFydGVkJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDE2LiB0ZXN0IGNvbXBsZXRlQ2hhbGxlbmdlIEFQSVxyXG4gICAgZGVzY3JpYmUoJ2NvbXBsZXRlQ2hhbGxlbmdlJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgY29tcGxldGUgY2hhbGxlbmdlIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NoYWxsZW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiB7IGVxdWFsczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSB9LFxyXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQXQ6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrQWR2ZW50dXJlUHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgICAgICBhZHZlbnR1cmVJZDogeyBlcXVhbHM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSkgfSxcclxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZXM6IFttb2NrQ2hhbGxlbmdlXSwgXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgIGlzQWR2ZW50dXJlQ29tcGxldGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2luLXByb2dyZXNzJyxcclxuICAgICAgICAgICAgICAgIHN0YXJzUmV3YXJkOiAxMDAsIFxyXG4gICAgICAgICAgICAgICAgY29pbnNSZXdhcmQ6IDUwICBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgXHJcbiAgICAgICAgICAgICAgICBhZHZlbnR1cmVzOiBbbW9ja0FkdmVudHVyZVByb2dyZXNzXSxcclxuICAgICAgICAgICAgICAgIHN0YXJzOiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb2luczogMTAwLFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5SWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTInXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbW9ja0FkdmVudHVyZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIF9pZDogeyBlcXVhbHM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFyc1Jld2FyZDogMjUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbnNSZXdhcmQ6IDE1XHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbW9ja0FkdmVudHVyZS5maW5kQnlJZC5tb2NrUmV0dXJuVmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgbGVhbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tBZHZlbnR1cmVEYXRhKVxyXG4gICAgICAgICAgICB9IGFzIGFueSk7XHJcbiAgICAgICAgICAgIG1vY2tGYW1pbHkuZmluZEJ5SWRBbmRVcGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHsgXHJcbiAgICAgICAgICAgICAgICAgICAgYWR2ZW50dXJlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDE2J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNvbXBsZXRlQ2hhbGxlbmdlKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja0NoYWxsZW5nZS5pc0NvbXBsZXRlZCkudG9CZSh0cnVlKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tDaGFsbGVuZ2UuY29tcGxldGVkQXQpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXJEYXRhLnN0YXJzKS50b0JlKDIyNSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlckRhdGEuY29pbnMpLnRvQmUoMTY1KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBjb21wbGV0ZSBjaGFsbGVuZ2Ugd2l0aG91dCBhZHZlbnR1cmUgY29tcGxldGlvbiBib251cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NoYWxsZW5nZTEgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogeyBlcXVhbHM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSkgfSxcclxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEF0OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NoYWxsZW5nZTIgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogeyBlcXVhbHM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpIH0sXHJcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRBdDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tBZHZlbnR1cmVQcm9ncmVzcyA9IHtcclxuICAgICAgICAgICAgICAgIGFkdmVudHVyZUlkOiB7IGVxdWFsczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSB9LFxyXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlczogW21vY2tDaGFsbGVuZ2UxLCBtb2NrQ2hhbGxlbmdlMl0sIFxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgICAgICAgICAgICBpc0FkdmVudHVyZUNvbXBsZXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdpbi1wcm9ncmVzcycsXHJcbiAgICAgICAgICAgICAgICBzdGFyc1Jld2FyZDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29pbnNSZXdhcmQ6IDUwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IFxyXG4gICAgICAgICAgICAgICAgYWR2ZW50dXJlczogW21vY2tBZHZlbnR1cmVQcm9ncmVzc10sXHJcbiAgICAgICAgICAgICAgICBzdGFyczogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29pbnM6IDEwMCxcclxuICAgICAgICAgICAgICAgIGZhbWlseUlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDEyJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tBZHZlbnR1cmVEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlczogW3tcclxuICAgICAgICAgICAgICAgICAgICBfaWQ6IHsgZXF1YWxzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRydWUpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnNSZXdhcmQ6IDI1LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5zUmV3YXJkOiAxNVxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG1vY2tBZHZlbnR1cmUuZmluZEJ5SWQubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgICAgICAgICAgIGxlYW46IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQWR2ZW50dXJlRGF0YSlcclxuICAgICAgICAgICAgfSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRCeUlkQW5kVXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHt9IGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgXHJcbiAgICAgICAgICAgICAgICB1c2VyOiBtb2NrVXNlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGFkdmVudHVyZUlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDE1JyxcclxuICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxNidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjb21wbGV0ZUNoYWxsZW5nZShtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tDaGFsbGVuZ2UxLmlzQ29tcGxldGVkKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja0FkdmVudHVyZVByb2dyZXNzLnByb2dyZXNzKS50b0JlKDUwKTsgXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrQWR2ZW50dXJlUHJvZ3Jlc3MuaXNBZHZlbnR1cmVDb21wbGV0ZWQpLnRvQmUoZmFsc2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5zdGFycykudG9CZSgxMjUpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXJEYXRhLmNvaW5zKS50b0JlKDExNSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMSBpZiB1c2VyIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbnVsbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNvbXBsZXRlQ2hhbGxlbmdlKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDQgaWYgYWR2ZW50dXJlIG5vdCBmb3VuZCBpbiB1c2VyIHByb2ZpbGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGFkdmVudHVyZXM6IFtdIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBcclxuICAgICAgICAgICAgICAgICAgICBhZHZlbnR1cmVJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxNScsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTYnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgY29tcGxldGVDaGFsbGVuZ2UobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogXCJBZHZlbnR1cmUgbm90IGZvdW5kIGluIHVzZXIncyBwcm9maWxlXCIgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCBpZiBjaGFsbGVuZ2Ugbm90IGZvdW5kIGluIGFkdmVudHVyZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0FkdmVudHVyZVByb2dyZXNzID0ge1xyXG4gICAgICAgICAgICAgICAgYWR2ZW50dXJlSWQ6IHsgZXF1YWxzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRydWUpIH0sXHJcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VzOiBbXSwgLy8gTm8gY2hhbGxlbmdlc1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgICAgICAgICAgICBpc0FkdmVudHVyZUNvbXBsZXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdpbi1wcm9ncmVzcycsXHJcbiAgICAgICAgICAgICAgICBzdGFyc1Jld2FyZDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29pbnNSZXdhcmQ6IDUwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGFkdmVudHVyZXM6IFttb2NrQWR2ZW50dXJlUHJvZ3Jlc3NdIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBcclxuICAgICAgICAgICAgICAgICAgICBhZHZlbnR1cmVJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxNScsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTYnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgY29tcGxldGVDaGFsbGVuZ2UobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0NoYWxsZW5nZSBub3QgZm91bmQgaW4gYWR2ZW50dXJlJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA0IGlmIGFkdmVudHVyZSBkYXRhIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NoYWxsZW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiB7IGVxdWFsczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSB9LFxyXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tBZHZlbnR1cmVQcm9ncmVzcyA9IHtcclxuICAgICAgICAgICAgICAgIGFkdmVudHVyZUlkOiB7IGVxdWFsczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSB9LFxyXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlczogW21vY2tDaGFsbGVuZ2VdLFxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgYWR2ZW50dXJlczogW21vY2tBZHZlbnR1cmVQcm9ncmVzc10gfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBtb2NrQWR2ZW50dXJlLmZpbmRCeUlkLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBsZWFuOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobnVsbClcclxuICAgICAgICAgICAgfSBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyBcclxuICAgICAgICAgICAgICAgICAgICBhZHZlbnR1cmVJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxNScsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTYnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgY29tcGxldGVDaGFsbGVuZ2UobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0FkdmVudHVyZSBub3QgZm91bmQnIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMTcuIHRlc3QgZ2V0VXNlckFkdmVudHVyZXMgQVBJXHJcbiAgICBkZXNjcmliZSgnZ2V0VXNlckFkdmVudHVyZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBnZXQgdXNlciBhZHZlbnR1cmVzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0FkdmVudHVyZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IGFkdmVudHVyZUlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDE1Jywgc3RhdHVzOiAnaW4tcHJvZ3Jlc3MnIH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgYWR2ZW50dXJlczogbW9ja0FkdmVudHVyZXMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyQWR2ZW50dXJlcyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVzZXIgYWR2ZW50dXJlcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBBZHZlbnR1cmU6IG1vY2tBZHZlbnR1cmVzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgdXNlciBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG51bGwgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyQWR2ZW50dXJlcyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDE4LiB0ZXN0IGdldFVzZXJQdXJjaGFzZWRJdGVtcyBBUElcclxuICAgIGRlc2NyaWJlKCdnZXRVc2VyUHVyY2hhc2VkSXRlbXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBnZXQgdXNlciBwdXJjaGFzZWQgaXRlbXMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUHVyY2hhc2VkSXRlbXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IGl0ZW1JZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAyMCcgfSxcclxuICAgICAgICAgICAgICAgIHsgaXRlbUlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDIxJyB9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIHB1cmNoYXNlZEl0ZW1zOiBtb2NrUHVyY2hhc2VkSXRlbXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEb2MgPSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRCeUlkLm1vY2tSZXR1cm5WYWx1ZShtb2NrVXNlckRvYyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKCksXHJcbiAgICAgICAgICAgICAgICBib2R5OiB7IHVzZXJJZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJQdXJjaGFzZWRJdGVtcyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlB1cmNoYXNlZCBpdGVtcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICBwdXJjaGFzZWRJdGVtczogWyc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMjAnLCAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDIxJ11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMSBpZiB1c2VyIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgdXNlcjogbnVsbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJQdXJjaGFzZWRJdGVtcyhtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAzIGlmIHRyeWluZyB0byBhY2Nlc3Mgb3RoZXIgdXNlciBpdGVtcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgX2lkOiAnZGlmZmVyZW50LXVzZXItaWQnIH0pLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyUHVyY2hhc2VkSXRlbXMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAzKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ0ZvcmJpZGRlbicgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCBpZiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEb2MgPSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kQnlJZC5tb2NrUmV0dXJuVmFsdWUobW9ja1VzZXJEb2MgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpLFxyXG4gICAgICAgICAgICAgICAgYm9keTogeyB1c2VySWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBnZXRVc2VyUHVyY2hhc2VkSXRlbXMobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBlcnJvcjogJ1VzZXIgbm90IGZvdW5kJyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdnZXRVc2VyQXZhdGFyJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgZ2V0IHVzZXIgYXZhdGFyIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgXHJcbiAgICAgICAgICAgICAgICBhdmF0YXI6ICcvYXZhdGFycy9jaGlsZC1ib3ktMS5wbmcnIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJBdmF0YXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBdmF0YXIgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgYXZhdGFyOiAnL2F2YXRhcnMvY2hpbGQtYm95LTEucG5nJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGlmIHVzZXIgbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgZ2V0VXNlckF2YXRhcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiVW5hdXRob3JpemVkXCIgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgYXZhdGFyIGZvcm1hdHMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IGF2YXRhcjogJy9hdmF0YXJzL3BhcmVudC13b21hbi5wbmcnLCBkZXNjcmlwdGlvbjogJ3BhcmVudCBhdmF0YXInIH0sXHJcbiAgICAgICAgICAgICAgICB7IGF2YXRhcjogJy9hdmF0YXJzL2NoaWxkLWdpcmwtMi5wbmcnLCBkZXNjcmlwdGlvbjogJ2NoaWxkIGF2YXRhcicgfSxcclxuICAgICAgICAgICAgICAgIHsgYXZhdGFyOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hdmF0YXIuanBnJywgZGVzY3JpcHRpb246ICdleHRlcm5hbCBVUkwnIH0sXHJcbiAgICAgICAgICAgICAgICB7IGF2YXRhcjogJy9kZWZhdWx0LWF2YXRhci5zdmcnLCBkZXNjcmlwdGlvbjogJ2RlZmF1bHQgYXZhdGFyJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBhdmF0YXI6ICcnLCBkZXNjcmlwdGlvbjogJ2VtcHR5IHN0cmluZycgfSxcclxuICAgICAgICAgICAgICAgIHsgYXZhdGFyOiBudWxsLCBkZXNjcmlwdGlvbjogJ251bGwgYXZhdGFyJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBhdmF0YXI6IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246ICd1bmRlZmluZWQgYXZhdGFyJyB9XHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgYXZhdGFyLCBkZXNjcmlwdGlvbiB9IG9mIHRlc3RDYXNlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHsgYXZhdGFyIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IHVzZXI6IG1vY2tVc2VyRGF0YSB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgZ2V0VXNlckF2YXRhcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkF2YXRhciByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXZhdGFyOiBhdmF0YXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZlciBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbm9ybWFsIHVzZXIgb2JqZWN0IGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVGhlbiBvdmVycmlkZSB0aGUgYXZhdGFyIHByb3BlcnR5IHdpdGggYSBnZXR0ZXIgdGhhdCB0aHJvd3NcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vY2tVc2VyRGF0YSwgJ2F2YXRhcicsIHtcclxuICAgICAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJBdmF0YXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNTAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBcclxuICAgICAgICAgICAgICAgIGVycm9yOiBcIkVycm9yIGZldGNoaW5nIGF2YXRhclwiIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHVzZXIgd2l0aCBhbGwgYXZhdGFyIGVkZ2UgY2FzZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgdmFyaW91cyBlZGdlIGNhc2VzIGZvciBhdmF0YXIgcHJvcGVydHlcclxuICAgICAgICAgICAgY29uc3QgZWRnZUNhc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgeyBhdmF0YXI6IDAsIGRlc2NyaXB0aW9uOiAnbnVtYmVyIHplcm8nIH0sXHJcbiAgICAgICAgICAgICAgICB7IGF2YXRhcjogZmFsc2UsIGRlc2NyaXB0aW9uOiAnYm9vbGVhbiBmYWxzZScgfSxcclxuICAgICAgICAgICAgICAgIHsgYXZhdGFyOiBbXSwgZGVzY3JpcHRpb246ICdlbXB0eSBhcnJheScgfSxcclxuICAgICAgICAgICAgICAgIHsgYXZhdGFyOiB7fSwgZGVzY3JpcHRpb246ICdlbXB0eSBvYmplY3QnIH0sXHJcbiAgICAgICAgICAgICAgICB7IGF2YXRhcjogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZSNDJtUDgvNStoSGdBSGdnSi9QY2hJN3dBQUFBQkpSVTVFcmtKZ2dnPT0nLCBkZXNjcmlwdGlvbjogJ2Jhc2U2NCBpbWFnZScgfVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGF2YXRhciwgZGVzY3JpcHRpb24gfSBvZiBlZGdlQ2FzZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7IGF2YXRhciB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyB1c2VyOiBtb2NrVXNlckRhdGEgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IGdldFVzZXJBdmF0YXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBdmF0YXIgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGF2YXRhcjogYXZhdGFyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2VyIG9iamVjdCB3aXRob3V0IGF2YXRhciBwcm9wZXJ0eScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aG91dCBhdmF0YXIgcHJvcGVydHlcclxuICAgICAgICAgICAgY29uc3QgdXNlcldpdGhvdXRBdmF0YXIgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoKTtcclxuICAgICAgICAgICAgZGVsZXRlICh1c2VyV2l0aG91dEF2YXRhciBhcyBhbnkpLmF2YXRhcjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IHVzZXJXaXRob3V0QXZhdGFyIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJBdmF0YXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBdmF0YXIgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgYXZhdGFyOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgd29yayB3aXRoIG1pbmltYWwgdXNlciBvYmplY3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRlc3Qgd2l0aCB2ZXJ5IGJhc2ljIHVzZXIgb2JqZWN0XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbmltYWxVc2VyID0ge1xyXG4gICAgICAgICAgICAgICAgX2lkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyxcclxuICAgICAgICAgICAgICAgIGF2YXRhcjogJy9zaW1wbGUtYXZhdGFyLnBuZydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1pbmltYWxVc2VyIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGdldFVzZXJBdmF0YXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBdmF0YXIgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseVwiLFxyXG4gICAgICAgICAgICAgICAgYXZhdGFyOiAnL3NpbXBsZS1hdmF0YXIucG5nJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJtb2NrVXNlciIsIlVzZXIiLCJtb2NrQWR2ZW50dXJlIiwiQWR2ZW50dXJlIiwibW9ja0ZhbWlseSIsIkZhbWlseSIsIm1vY2tHZW5lcmF0ZVNlY3VyZVBhc3N3b3JkIiwiZ2VuZXJhdGVTZWN1cmVQYXNzd29yZCIsIm1vY2tDaGVja0lkIiwiY2hlY2tJZCIsIm1vY2tFbWFpbFNlcnZpY2UiLCJlbWFpbFNlcnZpY2UiLCJtb2NrUmVjYWxjdWxhdGVGYW1pbHlNZW1iZXJSYW5rcyIsInJlY2FsY3VsYXRlRmFtaWx5TWVtYmVyUmFua3MiLCJtb2NrQmNyeXB0IiwiYmNyeXB0IiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImZpbmQiLCJmbiIsImZpbmRPbmUiLCJmaW5kQnlJZCIsImNyZWF0ZSIsImZpbmRCeUlkQW5kVXBkYXRlIiwiZmluZEJ5SWRBbmREZWxldGUiLCJjb3VudERvY3VtZW50cyIsIm1vY2tSZXR1cm5WYWx1ZSIsInNweU9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1bmRlZmluZWQiLCJpdCIsIm1vY2tVc2VycyIsInRlc3RVdGlscyIsImNyZWF0ZU1vY2tVc2VyIiwibmFtZSIsIl9pZCIsIm1vY2tSZXEiLCJjcmVhdGVNb2NrUmVxdWVzdCIsIm1vY2tSZXMiLCJjcmVhdGVNb2NrUmVzcG9uc2UiLCJnZXRVc2VycyIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInN0YXR1cyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic2VuZCIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJqc29uIiwiZXJyb3IiLCJtb2NrVXNlcl9kYXRhIiwibW9ja1VzZXJEb2MiLCJzZWxlY3QiLCJ1c2VyIiwiYm9keSIsInVzZXJJZCIsImdldFVzZXJCeUlkIiwibWVzc2FnZSIsImVtYWlsIiwicm9sZSIsInZhbGlkVXNlckRhdGEiLCJiaXJ0aGRheSIsImdlbmRlciIsImF2YXRhciIsImludGVyZXN0cyIsIm1vY2tQYXJlbnQiLCJtb2NrRmFtaWx5RGF0YSIsImNyZWF0ZU1vY2tGYW1pbHkiLCJtZW1iZXJzIiwibW9ja0NyZWF0ZWRVc2VyIiwiY3JlYXRlVXNlciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJzZW5kTWFpbCIsIm1vY2tDaGlsZCIsImluY29tcGxldGVEYXRhIiwiZXhpc3RpbmdVc2VyIiwiaW52YWxpZERhdGEiLCJtb2NrVXNlckRhdGEiLCJlZGl0VXNlclByb2ZpbGUiLCJhbnkiLCJPYmplY3QiLCJkZWxldGVVc2VyIiwiY29tcGFyZSIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsIm9sZFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJjb25maXJtUGFzc3dvcmQiLCJ1cGRhdGVQYXNzd29yZCIsInBhc3N3b3JkIiwic3RhcnMiLCJnZXRVc2VyU3RhcnMiLCJmYW1pbHlJZCIsInVwZGF0ZVVzZXJTdGFycyIsInRvQmUiLCIkaW5jIiwidG90YWxTdGFycyIsInNhdmUiLCJjb2lucyIsImdldFVzZXJDb2lucyIsInVwZGF0ZVVzZXJDb2lucyIsImN1cnJlbnRMb2NhdGlvbiIsImdldExvY2F0aW9uIiwibG9jYXRpb24iLCJ1cGRhdGVMb2NhdGlvbiIsInJhbmtJbkZhbWlseSIsImdldFVzZXJSYW5rIiwiUmFuayIsImdldFVzZXJJbnRlcmVzdHMiLCJJbnRlcmVzdHMiLCJhZHZlbnR1cmVzIiwibW9ja0FkdmVudHVyZURhdGEiLCJjcmVhdGVNb2NrQWR2ZW50dXJlIiwiYWR2ZW50dXJlSWQiLCJzdGFydEFkdmVudHVyZSIsInRvSGF2ZUxlbmd0aCIsImV4aXN0aW5nQWR2ZW50dXJlIiwiZXF1YWxzIiwiY2hhbGxlbmdlcyIsImlzQWR2ZW50dXJlQ29tcGxldGVkIiwic3RhcnNSZXdhcmQiLCJjb2luc1Jld2FyZCIsInByb2dyZXNzIiwibW9ja0NoYWxsZW5nZSIsImNoYWxsZW5nZUlkIiwiaXNDb21wbGV0ZWQiLCJjb21wbGV0ZWRBdCIsIm1vY2tBZHZlbnR1cmVQcm9ncmVzcyIsImxlYW4iLCJjb21wbGV0ZUNoYWxsZW5nZSIsInRvQmVEZWZpbmVkIiwibW9ja0NoYWxsZW5nZTEiLCJtb2NrQ2hhbGxlbmdlMiIsIm1vY2tBZHZlbnR1cmVzIiwiZ2V0VXNlckFkdmVudHVyZXMiLCJtb2NrUHVyY2hhc2VkSXRlbXMiLCJpdGVtSWQiLCJwdXJjaGFzZWRJdGVtcyIsImdldFVzZXJQdXJjaGFzZWRJdGVtcyIsImdldFVzZXJBdmF0YXIiLCJ0ZXN0Q2FzZXMiLCJkZXNjcmlwdGlvbiIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY29uZmlndXJhYmxlIiwiZWRnZUNhc2VzIiwidXNlcldpdGhvdXRBdmF0YXIiLCJtaW5pbWFsVXNlciJdLCJtYXBwaW5ncyI6IjtBQWdCQSx3QkFBd0I7QUFDeEJBLEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7Ozs7dUJBeEJnQjtnQ0FNbkI7MkJBQ2M7Z0ZBQ21CO2lFQUNmO2dDQUNDOzZCQUNIO3NFQUNPO3NGQUNnQjtnRUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVl4QixNQUFNQyxXQUFXQyxlQUFJO0FBQ3JCLE1BQU1DLGdCQUFnQkMseUJBQVM7QUFDL0IsTUFBTUMsYUFBYUMsbUJBQU07QUFDekIsTUFBTUMsNkJBQTZCQztBQUNuQyxNQUFNQyxjQUFjQztBQUNwQixNQUFNQyxtQkFBbUJDO0FBQ3pCLE1BQU1DLG1DQUFtQ0M7QUFDekMsTUFBTUMsYUFBYUM7QUFFbkJDLFNBQVMseUJBQXlCO0lBQzlCQyxXQUFXO1FBQ1BuQixLQUFLb0IsYUFBYTtRQUVsQiwyQkFBMkI7UUFDM0JsQixTQUFTbUIsSUFBSSxHQUFHckIsS0FBS3NCLEVBQUU7UUFDdkJwQixTQUFTcUIsT0FBTyxHQUFHdkIsS0FBS3NCLEVBQUU7UUFDMUJwQixTQUFTc0IsUUFBUSxHQUFH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