8b4bdf6550d6f591c7d82e290cdbc8b6
"use strict";
// Mock all dependencies
jest.mock('../../src/models/user.model');
jest.mock('../../src/models/family.model');
jest.mock('../../src/services/email.service');
jest.mock('../../src/utils/generateSecurePassword');
jest.mock('bcrypt');
jest.mock('jsonwebtoken');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _setup = require("../setup");
const _authcontroller = require("../../src/controllers/auth.controller");
const _usermodel = require("../../src/models/user.model");
const _familymodel = require("../../src/models/family.model");
const _generateSecurePassword = /*#__PURE__*/ _interop_require_wildcard(require("../../src/utils/generateSecurePassword"));
const _emailservice = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/email.service"));
const _bcrypt = /*#__PURE__*/ _interop_require_wildcard(require("bcrypt"));
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockUser = _usermodel.User;
const mockFamily = _familymodel.Family;
const mockGenerateSecurePassword = _generateSecurePassword;
const mockEmailService = _emailservice;
const mockBcrypt = _bcrypt;
const mockJwt = _jsonwebtoken.default;
describe('Auth Controller Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup User model methods
        mockUser.findOne = jest.fn();
        mockUser.create = jest.fn();
        // Setup Family model methods
        mockFamily.findOne = jest.fn();
        // Setup utility mocks
        mockGenerateSecurePassword.generateSecurePassword.mockReturnValue('TempPass123!');
        jest.spyOn(mockEmailService, 'sendMail').mockResolvedValue(undefined);
        jest.spyOn(_bcrypt, 'hash').mockResolvedValue('hashedPassword');
        jest.spyOn(_bcrypt, 'compare').mockResolvedValue(true);
        jest.spyOn(_jsonwebtoken.default, 'sign').mockResolvedValue('mock-jwt-token');
        // Set JWT_SECRET environment variable
        process.env.JWT_SECRET = 'test_jwt_secret_key_for_guardian_grove_123';
    });
    afterEach(()=>{
        // Clean up environment variables if needed
        if (!process.env.JWT_SECRET) {
            process.env.JWT_SECRET = 'test_jwt_secret_key_for_guardian_grove_123';
        }
    });
    // 1. test login API
    describe('login', ()=>{
        const validLoginData = {
            name: 'Test User',
            email: 'test@example.com',
            password: 'TestPass123!'
        };
        it('should login successfully with valid credentials', async ()=>{
            const mockUserData = {
                ..._setup.testUtils.createMockUser({
                    ...validLoginData,
                    isTempPassword: false
                }),
                id: '507f1f77bcf86cd799439011'
            };
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(true);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockUser.findOne).toHaveBeenCalledWith({
                name: validLoginData.name,
                email: validLoginData.email
            });
            expect(mockBcrypt.compare).toHaveBeenCalledWith(validLoginData.password, mockUserData.password);
            expect(mockJwt.sign).toHaveBeenCalledWith({
                userId: mockUserData.id,
                role: mockUserData.role
            }, 'test_jwt_secret_key_for_guardian_grove_123');
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                user: mockUserData,
                token: 'mock-jwt-token',
                requiresPasswordChange: false,
                message: 'Login successful'
            });
        });
        it('should login with temporary password and require password change', async ()=>{
            const mockUserData = {
                ..._setup.testUtils.createMockUser({
                    ...validLoginData,
                    isTempPassword: true
                }),
                id: '507f1f77bcf86cd799439011' // Add id property for JWT
            };
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(true);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.json).toHaveBeenCalledWith({
                user: mockUserData,
                token: 'mock-jwt-token',
                requiresPasswordChange: true,
                message: 'Please set a new password'
            });
        });
        it('should return 400 if required fields are missing', async ()=>{
            const incompleteData = {
                name: 'Test User',
                email: 'test@example.com'
            }; // Missing password
            const mockReq = _setup.testUtils.createMockRequest({
                body: incompleteData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Name, email, and password are required.'
            });
        });
        it('should return 404 if user not found', async ()=>{
            mockUser.findOne.mockResolvedValue(null);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid credentials. User not found.'
            });
        });
        it('should return 401 if password is incorrect', async ()=>{
            const mockUserData = {
                ..._setup.testUtils.createMockUser(validLoginData),
                id: '507f1f77bcf86cd799439011'
            };
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(false);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(401);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid password.'
            });
        });
        it('should handle JWT signing errors gracefully', async ()=>{
            const mockUserData = {
                ..._setup.testUtils.createMockUser(validLoginData),
                id: '507f1f77bcf86cd799439011'
            };
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockBcrypt.compare.mockResolvedValue(true);
            // Mock JWT sign to throw an error
            mockJwt.sign.mockRejectedValue(new Error('JWT signing failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Something went wrong while logging in.'
            });
        });
        it('should handle database errors gracefully', async ()=>{
            mockUser.findOne.mockRejectedValue(new Error('Database connection failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validLoginData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.login)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Something went wrong while logging in.'
            });
        });
    });
    // 2. test register API
    describe('register', ()=>{
        const validRegisterData = {
            name: 'Test Parent',
            email: 'parent@example.com',
            password: 'TestPass123!',
            confirmPassword: 'TestPass123!',
            birthday: '1985-01-01',
            gender: 'male',
            role: 'parent',
            avatar: '/avatar.png',
            interests: [
                'reading',
                'sports'
            ],
            familyName: 'Test Family',
            familyAvatar: '/family-avatar.png'
        };
        it('should register successfully with valid data', async ()=>{
            const mockFamilyData = _setup.testUtils.createMockFamily({
                email: validRegisterData.email,
                familyName: validRegisterData.familyName,
                members: []
            });
            const mockCreatedUser = {
                ..._setup.testUtils.createMockUser({
                    ...validRegisterData,
                    familyId: mockFamilyData._id
                }),
                id: '507f1f77bcf86cd799439011' // Add id property for JWT
            };
            mockFamily.findOne.mockResolvedValue(null); // New family
            mockFamily.prototype.save = jest.fn().mockResolvedValue(mockFamilyData);
            mockUser.findOne.mockResolvedValue(null); // No existing user with same name
            mockUser.create.mockResolvedValue(mockCreatedUser);
            // Mock the Family constructor
            mockFamily.mockImplementation(()=>({
                    ...mockFamilyData,
                    save: jest.fn().mockResolvedValue(mockFamilyData)
                }));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validRegisterData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockBcrypt.hash).toHaveBeenCalledWith(validRegisterData.password, 12);
            expect(mockUser.create).toHaveBeenCalled();
            expect(mockJwt.sign).toHaveBeenCalledWith({
                userId: mockCreatedUser.id,
                role: mockCreatedUser.role
            }, 'test_jwt_secret_key_for_guardian_grove_123');
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should register with existing family', async ()=>{
            const mockFamilyData = _setup.testUtils.createMockFamily({
                email: validRegisterData.email,
                familyName: validRegisterData.familyName,
                members: []
            });
            mockFamilyData.save = jest.fn().mockResolvedValue(mockFamilyData);
            const mockCreatedUser = {
                ..._setup.testUtils.createMockUser({
                    ...validRegisterData,
                    familyId: mockFamilyData._id
                }),
                id: '507f1f77bcf86cd799439011' // Add id property for JWT
            };
            mockFamily.findOne.mockResolvedValue(mockFamilyData);
            mockUser.findOne.mockResolvedValue(null);
            mockUser.create.mockResolvedValue(mockCreatedUser);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validRegisterData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(200);
        });
        it('should return 400 if required fields are missing', async ()=>{
            const incompleteData = {
                ...validRegisterData
            };
            delete incompleteData.name;
            const mockReq = _setup.testUtils.createMockRequest({
                body: incompleteData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'All required fields must be filled.'
            });
        });
        it('should return 400 if passwords do not match', async ()=>{
            const invalidData = {
                ...validRegisterData,
                confirmPassword: 'DifferentPass123!'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Passwords do not match'
            });
        });
        it('should return 400 if email format is invalid', async ()=>{
            const invalidData = {
                ...validRegisterData,
                email: 'invalid-email'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid email format.'
            });
        });
        it('should return 400 if role is child', async ()=>{
            const invalidData = {
                ...validRegisterData,
                role: 'child'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Children must be added by a parent.'
            });
        });
        it('should return 400 if role is invalid', async ()=>{
            const invalidData = {
                ...validRegisterData,
                role: 'invalid-role'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid role.'
            });
        });
        it('should return 400 if interests is not an array', async ()=>{
            const invalidData = {
                ...validRegisterData,
                interests: 'not-an-array'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Interests must be an array.'
            });
        });
        it('should return 400 if gender is invalid', async ()=>{
            const invalidData = {
                ...validRegisterData,
                gender: 'invalid-gender'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: "Gender must be either 'male' or 'female'."
            });
        });
        it('should return 400 if birthday format is invalid', async ()=>{
            const invalidData = {
                ...validRegisterData,
                birthday: 'invalid-date'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid birthday format.'
            });
        });
        it('should return 400 if password does not meet requirements', async ()=>{
            const invalidData = {
                ...validRegisterData,
                password: 'weak',
                confirmPassword: 'weak'
            };
            const mockReq = _setup.testUtils.createMockRequest({
                body: invalidData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Password must be at least 8 characters long, include an uppercase letter, lowercase letter, a number, and a special character.'
            });
        });
        it('should return 400 if family name is wrong for existing family', async ()=>{
            const mockFamilyData = _setup.testUtils.createMockFamily({
                email: validRegisterData.email,
                familyName: 'Different Family Name'
            });
            mockFamily.findOne.mockResolvedValue(mockFamilyData);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validRegisterData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Wrong family name'
            });
        });
        it('should return 400 if member with same name exists in family', async ()=>{
            const mockFamilyData = _setup.testUtils.createMockFamily({
                email: validRegisterData.email,
                familyName: validRegisterData.familyName
            });
            const existingUser = _setup.testUtils.createMockUser({
                name: validRegisterData.name,
                familyId: mockFamilyData._id
            });
            mockFamily.findOne.mockResolvedValue(mockFamilyData);
            mockUser.findOne.mockResolvedValue(existingUser);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validRegisterData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(400);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'A member with this name already exists in the family.'
            });
        });
        it('should handle database errors gracefully', async ()=>{
            mockFamily.findOne.mockRejectedValue(new Error('Database connection failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validRegisterData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.register)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Something went wrong while registering.'
            });
        });
    });
    // 3. test forgetPassword API
    describe('forgetPassword', ()=>{
        const validForgetPasswordData = {
            name: 'Test User',
            email: 'test@example.com'
        };
        it('should send temporary password successfully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser(validForgetPasswordData);
            mockUser.findOne.mockResolvedValue(mockUserData);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockUser.findOne).toHaveBeenCalledWith({
                email: validForgetPasswordData.email,
                name: validForgetPasswordData.name
            });
            expect(mockGenerateSecurePassword.generateSecurePassword).toHaveBeenCalled();
            expect(mockBcrypt.hash).toHaveBeenCalledWith('TempPass123!', 12);
            expect(mockUserData.isTempPassword).toBe(true);
            expect(mockUserData.passwordChangedAt).toBeDefined();
            expect(mockEmailService.sendMail).toHaveBeenCalledWith(expect.stringContaining('Guardian Grove'), validForgetPasswordData.email, 'Your Temporary Password', expect.stringContaining('TempPass123!'));
            expect(mockRes.status).toHaveBeenCalledWith(200);
            expect(mockRes.send).toHaveBeenCalledWith({
                message: 'Temporary password sent to your email.'
            });
        });
        it('should return 404 if user not found', async ()=>{
            mockUser.findOne.mockResolvedValue(null);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(404);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Invalid credentials. User not found.'
            });
        });
        it('should handle email service errors gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser(validForgetPasswordData);
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockEmailService.sendMail.mockRejectedValue(new Error('Email service failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error sending temporary password.'
            });
        });
        it('should handle database save errors gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser(validForgetPasswordData);
            mockUserData.save = jest.fn().mockRejectedValue(new Error('Database save failed'));
            mockUser.findOne.mockResolvedValue(mockUserData);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error sending temporary password.'
            });
        });
        it('should handle password hashing errors gracefully', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser(validForgetPasswordData);
            mockUser.findOne.mockResolvedValue(mockUserData);
            mockBcrypt.hash.mockRejectedValue(new Error('Hashing failed'));
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockRes.status).toHaveBeenCalledWith(500);
            expect(mockRes.json).toHaveBeenCalledWith({
                error: 'Error sending temporary password.'
            });
        });
        it('should generate proper email HTML content', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                ...validForgetPasswordData,
                name: 'John Doe'
            });
            mockUser.findOne.mockResolvedValue(mockUserData);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockEmailService.sendMail).toHaveBeenCalledWith(expect.any(String), validForgetPasswordData.email, 'Your Temporary Password', expect.stringMatching(/Hello John Doe/));
            expect(mockEmailService.sendMail).toHaveBeenCalledWith(expect.any(String), validForgetPasswordData.email, 'Your Temporary Password', expect.stringMatching(/TempPass123!/));
            expect(mockEmailService.sendMail).toHaveBeenCalledWith(expect.any(String), validForgetPasswordData.email, 'Your Temporary Password', expect.stringMatching(/Guardian Grove Team/));
        });
        it('should set correct user properties after password reset', async ()=>{
            const mockUserData = _setup.testUtils.createMockUser({
                ...validForgetPasswordData,
                isTempPassword: false,
                passwordChangedAt: new Date('2024-01-01')
            });
            mockUser.findOne.mockResolvedValue(mockUserData);
            const mockReq = _setup.testUtils.createMockRequest({
                body: validForgetPasswordData
            });
            const mockRes = _setup.testUtils.createMockResponse();
            await (0, _authcontroller.forgetPassword)(mockReq, mockRes);
            expect(mockUserData.password).toBe('hashedPassword');
            expect(mockUserData.isTempPassword).toBe(true);
            expect(mockUserData.passwordChangedAt).toBeInstanceOf(Date);
            expect(mockUserData.save).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVVNFUlxcRGVza3RvcFxcZ3VhcmRpYW4tZ3JvdmVcXGd1YXJkaWFuLWdyb3ZlLWJhY2tlbmRcXHRlc3RzXFxjb250cm9sbGVyc1xcYXV0aC5jb250cm9sbGVyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGVzdFV0aWxzIH0gZnJvbSAnLi4vc2V0dXAnO1xyXG5pbXBvcnQgeyBsb2dpbiwgcmVnaXN0ZXIsIGZvcmdldFBhc3N3b3JkIH0gZnJvbSAnLi4vLi4vc3JjL2NvbnRyb2xsZXJzL2F1dGguY29udHJvbGxlcic7XHJcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi8uLi9zcmMvbW9kZWxzL3VzZXIubW9kZWwnO1xyXG5pbXBvcnQgeyBGYW1pbHkgfSBmcm9tICcuLi8uLi9zcmMvbW9kZWxzL2ZhbWlseS5tb2RlbCc7XHJcbmltcG9ydCAqIGFzIGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQgZnJvbSAnLi4vLi4vc3JjL3V0aWxzL2dlbmVyYXRlU2VjdXJlUGFzc3dvcmQnO1xyXG5pbXBvcnQgKiBhcyBlbWFpbFNlcnZpY2UgZnJvbSAnLi4vLi4vc3JjL3NlcnZpY2VzL2VtYWlsLnNlcnZpY2UnO1xyXG5pbXBvcnQgKiBhcyBiY3J5cHQgZnJvbSAnYmNyeXB0JztcclxuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xyXG5cclxuLy8gTW9jayBhbGwgZGVwZW5kZW5jaWVzXHJcbmplc3QubW9jaygnLi4vLi4vc3JjL21vZGVscy91c2VyLm1vZGVsJyk7XHJcbmplc3QubW9jaygnLi4vLi4vc3JjL21vZGVscy9mYW1pbHkubW9kZWwnKTtcclxuamVzdC5tb2NrKCcuLi8uLi9zcmMvc2VydmljZXMvZW1haWwuc2VydmljZScpO1xyXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy91dGlscy9nZW5lcmF0ZVNlY3VyZVBhc3N3b3JkJyk7XHJcbmplc3QubW9jaygnYmNyeXB0Jyk7XHJcbmplc3QubW9jaygnanNvbndlYnRva2VuJyk7XHJcblxyXG5jb25zdCBtb2NrVXNlciA9IFVzZXIgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIFVzZXI+O1xyXG5jb25zdCBtb2NrRmFtaWx5ID0gRmFtaWx5IGFzIGplc3QuTW9ja2VkPHR5cGVvZiBGYW1pbHk+O1xyXG5jb25zdCBtb2NrR2VuZXJhdGVTZWN1cmVQYXNzd29yZCA9IGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQ+O1xyXG5jb25zdCBtb2NrRW1haWxTZXJ2aWNlID0gZW1haWxTZXJ2aWNlIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBlbWFpbFNlcnZpY2U+O1xyXG5jb25zdCBtb2NrQmNyeXB0ID0gYmNyeXB0IGFzIGplc3QuTW9ja2VkPHR5cGVvZiBiY3J5cHQ+O1xyXG5jb25zdCBtb2NrSnd0ID0gand0IGFzIGplc3QuTW9ja2VkPHR5cGVvZiBqd3Q+O1xyXG5cclxuZGVzY3JpYmUoJ0F1dGggQ29udHJvbGxlciBUZXN0cycsICgpID0+IHtcclxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNldHVwIFVzZXIgbW9kZWwgbWV0aG9kc1xyXG4gICAgICAgIG1vY2tVc2VyLmZpbmRPbmUgPSBqZXN0LmZuKCk7XHJcbiAgICAgICAgbW9ja1VzZXIuY3JlYXRlID0gamVzdC5mbigpO1xyXG5cclxuICAgICAgICAvLyBTZXR1cCBGYW1pbHkgbW9kZWwgbWV0aG9kc1xyXG4gICAgICAgIG1vY2tGYW1pbHkuZmluZE9uZSA9IGplc3QuZm4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXR1cCB1dGlsaXR5IG1vY2tzXHJcbiAgICAgICAgbW9ja0dlbmVyYXRlU2VjdXJlUGFzc3dvcmQuZ2VuZXJhdGVTZWN1cmVQYXNzd29yZC5tb2NrUmV0dXJuVmFsdWUoJ1RlbXBQYXNzMTIzIScpO1xyXG4gICAgICAgIGplc3Quc3B5T24obW9ja0VtYWlsU2VydmljZSwgJ3NlbmRNYWlsJykubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuICAgICAgICBcclxuICAgICAgICAoamVzdC5zcHlPbihiY3J5cHQsICdoYXNoJykgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnaGFzaGVkUGFzc3dvcmQnKTtcclxuICAgICAgICAoamVzdC5zcHlPbihiY3J5cHQsICdjb21wYXJlJykgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuICAgICAgICAoamVzdC5zcHlPbihqd3QsICdzaWduJykgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnbW9jay1qd3QtdG9rZW4nKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IEpXVF9TRUNSRVQgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICAgICAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Rfand0X3NlY3JldF9rZXlfZm9yX2d1YXJkaWFuX2dyb3ZlXzEyMyc7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIC8vIENsZWFuIHVwIGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkpXVF9TRUNSRVQpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0X2p3dF9zZWNyZXRfa2V5X2Zvcl9ndWFyZGlhbl9ncm92ZV8xMjMnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDEuIHRlc3QgbG9naW4gQVBJXHJcbiAgICBkZXNjcmliZSgnbG9naW4nLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRMb2dpbkRhdGEgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxyXG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogJ1Rlc3RQYXNzMTIzISdcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGxvZ2luIHN1Y2Nlc3NmdWxseSB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi50ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkTG9naW5EYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVGVtcFBhc3N3b3JkOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBpZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMScgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIChtb2NrQmNyeXB0LmNvbXBhcmUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZExvZ2luRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGxvZ2luKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXIuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogdmFsaWRMb2dpbkRhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB2YWxpZExvZ2luRGF0YS5lbWFpbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tCY3J5cHQuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodmFsaWRMb2dpbkRhdGEucGFzc3dvcmQsIG1vY2tVc2VyRGF0YS5wYXNzd29yZCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrSnd0LnNpZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICAgICAgICAgeyB1c2VySWQ6IG1vY2tVc2VyRGF0YS5pZCwgcm9sZTogbW9ja1VzZXJEYXRhLnJvbGUgfSxcclxuICAgICAgICAgICAgICAgICd0ZXN0X2p3dF9zZWNyZXRfa2V5X2Zvcl9ndWFyZGlhbl9ncm92ZV8xMjMnXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgdXNlcjogbW9ja1VzZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgdG9rZW46ICdtb2NrLWp3dC10b2tlbicsXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlc1Bhc3N3b3JkQ2hhbmdlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdMb2dpbiBzdWNjZXNzZnVsJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBsb2dpbiB3aXRoIHRlbXBvcmFyeSBwYXNzd29yZCBhbmQgcmVxdWlyZSBwYXNzd29yZCBjaGFuZ2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRMb2dpbkRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUZW1wUGFzc3dvcmQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgaWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnIC8vIEFkZCBpZCBwcm9wZXJ0eSBmb3IgSldUXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIChtb2NrQmNyeXB0LmNvbXBhcmUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZExvZ2luRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGxvZ2luKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIHVzZXI6IG1vY2tVc2VyRGF0YSxcclxuICAgICAgICAgICAgICAgIHRva2VuOiAnbW9jay1qd3QtdG9rZW4nLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZXNQYXNzd29yZENoYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2Ugc2V0IGEgbmV3IHBhc3N3b3JkJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5jb21wbGV0ZURhdGEgPSB7IG5hbWU6ICdUZXN0IFVzZXInLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH07IC8vIE1pc3NpbmcgcGFzc3dvcmRcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiBpbmNvbXBsZXRlRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGxvZ2luKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnTmFtZSwgZW1haWwsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA0IGlmIHVzZXIgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IHZhbGlkTG9naW5EYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgbG9naW4obW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDA0KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzLiBVc2VyIG5vdCBmb3VuZC4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgaWYgcGFzc3dvcmQgaXMgaW5jb3JyZWN0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrVXNlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi50ZXN0VXRpbHMuY3JlYXRlTW9ja1VzZXIodmFsaWRMb2dpbkRhdGEpLFxyXG4gICAgICAgICAgICAgICAgaWQ6ICc1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIChtb2NrQmNyeXB0LmNvbXBhcmUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogdmFsaWRMb2dpbkRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBsb2dpbihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDEpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgcGFzc3dvcmQuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgSldUIHNpZ25pbmcgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih2YWxpZExvZ2luRGF0YSksXHJcbiAgICAgICAgICAgICAgICBpZDogJzUwN2YxZjc3YmNmODZjZDc5OTQzOTAxMSdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuICAgICAgICAgICAgKG1vY2tCY3J5cHQuY29tcGFyZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xyXG4gICAgICAgICAgICAvLyBNb2NrIEpXVCBzaWduIHRvIHRocm93IGFuIGVycm9yXHJcbiAgICAgICAgICAgIChtb2NrSnd0LnNpZ24gYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0pXVCBzaWduaW5nIGZhaWxlZCcpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZExvZ2luRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGxvZ2luKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgbG9nZ2luZyBpbi4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJykpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IHZhbGlkTG9naW5EYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgbG9naW4obW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNTAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBsb2dnaW5nIGluLidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyLiB0ZXN0IHJlZ2lzdGVyIEFQSVxyXG4gICAgZGVzY3JpYmUoJ3JlZ2lzdGVyJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkUmVnaXN0ZXJEYXRhID0ge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBQYXJlbnQnLFxyXG4gICAgICAgICAgICBlbWFpbDogJ3BhcmVudEBleGFtcGxlLmNvbScsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnVGVzdFBhc3MxMjMhJyxcclxuICAgICAgICAgICAgY29uZmlybVBhc3N3b3JkOiAnVGVzdFBhc3MxMjMhJyxcclxuICAgICAgICAgICAgYmlydGhkYXk6ICcxOTg1LTAxLTAxJyxcclxuICAgICAgICAgICAgZ2VuZGVyOiAnbWFsZScsXHJcbiAgICAgICAgICAgIHJvbGU6ICdwYXJlbnQnLFxyXG4gICAgICAgICAgICBhdmF0YXI6ICcvYXZhdGFyLnBuZycsXHJcbiAgICAgICAgICAgIGludGVyZXN0czogWydyZWFkaW5nJywgJ3Nwb3J0cyddLFxyXG4gICAgICAgICAgICBmYW1pbHlOYW1lOiAnVGVzdCBGYW1pbHknLFxyXG4gICAgICAgICAgICBmYW1pbHlBdmF0YXI6ICcvZmFtaWx5LWF2YXRhci5wbmcnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZWdpc3RlciBzdWNjZXNzZnVsbHkgd2l0aCB2YWxpZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrRmFtaWx5RGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrRmFtaWx5KHtcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB2YWxpZFJlZ2lzdGVyRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgIGZhbWlseU5hbWU6IHZhbGlkUmVnaXN0ZXJEYXRhLmZhbWlseU5hbWUsXHJcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBbXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZWRVc2VyID0ge1xyXG4gICAgICAgICAgICAgICAgLi4udGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZFJlZ2lzdGVyRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBmYW1pbHlJZDogbW9ja0ZhbWlseURhdGEuX2lkXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyAvLyBBZGQgaWQgcHJvcGVydHkgZm9yIEpXVFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBOZXcgZmFtaWx5XHJcbiAgICAgICAgICAgIG1vY2tGYW1pbHkucHJvdG90eXBlLnNhdmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ZhbWlseURhdGEpO1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBObyBleGlzdGluZyB1c2VyIHdpdGggc2FtZSBuYW1lXHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ3JlYXRlZFVzZXIgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vY2sgdGhlIEZhbWlseSBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAobW9ja0ZhbWlseSBhcyBhbnkpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4ubW9ja0ZhbWlseURhdGEsXHJcbiAgICAgICAgICAgICAgICBzYXZlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ZhbWlseURhdGEpXHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZFJlZ2lzdGVyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHJlZ2lzdGVyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja0JjcnlwdC5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh2YWxpZFJlZ2lzdGVyRGF0YS5wYXNzd29yZCwgMTIpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXIuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrSnd0LnNpZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICAgICAgICAgeyB1c2VySWQ6IG1vY2tDcmVhdGVkVXNlci5pZCwgcm9sZTogbW9ja0NyZWF0ZWRVc2VyLnJvbGUgfSxcclxuICAgICAgICAgICAgICAgICd0ZXN0X2p3dF9zZWNyZXRfa2V5X2Zvcl9ndWFyZGlhbl9ncm92ZV8xMjMnXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjAwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZWdpc3RlciB3aXRoIGV4aXN0aW5nIGZhbWlseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0ZhbWlseURhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja0ZhbWlseSh7XHJcbiAgICAgICAgICAgICAgICBlbWFpbDogdmFsaWRSZWdpc3RlckRhdGEuZW1haWwsXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlOYW1lOiB2YWxpZFJlZ2lzdGVyRGF0YS5mYW1pbHlOYW1lLFxyXG4gICAgICAgICAgICAgICAgbWVtYmVyczogW11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vY2tGYW1pbHlEYXRhLnNhdmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0ZhbWlseURhdGEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZWRVc2VyID0ge1xyXG4gICAgICAgICAgICAgICAgLi4udGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHtcclxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZFJlZ2lzdGVyRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBmYW1pbHlJZDogbW9ja0ZhbWlseURhdGEuX2lkXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGlkOiAnNTA3ZjFmNzdiY2Y4NmNkNzk5NDM5MDExJyAvLyBBZGQgaWQgcHJvcGVydHkgZm9yIEpXVFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tGYW1pbHlEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ3JlYXRlZFVzZXIgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZFJlZ2lzdGVyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHJlZ2lzdGVyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDIwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluY29tcGxldGVEYXRhOiBQYXJ0aWFsPHR5cGVvZiB2YWxpZFJlZ2lzdGVyRGF0YT4gPSB7IC4uLnZhbGlkUmVnaXN0ZXJEYXRhIH07XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbmNvbXBsZXRlRGF0YS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IGluY29tcGxldGVEYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdBbGwgcmVxdWlyZWQgZmllbGRzIG11c3QgYmUgZmlsbGVkLidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBwYXNzd29yZHMgZG8gbm90IG1hdGNoJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkUmVnaXN0ZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgY29uZmlybVBhc3N3b3JkOiAnRGlmZmVyZW50UGFzczEyMyEnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogaW52YWxpZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZWdpc3Rlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1Bhc3N3b3JkcyBkbyBub3QgbWF0Y2gnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgZW1haWwgZm9ybWF0IGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgLi4udmFsaWRSZWdpc3RlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBlbWFpbDogJ2ludmFsaWQtZW1haWwnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogaW52YWxpZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZWdpc3Rlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgZW1haWwgZm9ybWF0LidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiByb2xlIGlzIGNoaWxkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkUmVnaXN0ZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogJ2NoaWxkJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IGludmFsaWREYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDaGlsZHJlbiBtdXN0IGJlIGFkZGVkIGJ5IGEgcGFyZW50LidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiByb2xlIGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgLi4udmFsaWRSZWdpc3RlckRhdGEsXHJcbiAgICAgICAgICAgICAgICByb2xlOiAnaW52YWxpZC1yb2xlJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IGludmFsaWREYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIHJvbGUuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIGludGVyZXN0cyBpcyBub3QgYW4gYXJyYXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgLi4udmFsaWRSZWdpc3RlckRhdGEsXHJcbiAgICAgICAgICAgICAgICBpbnRlcmVzdHM6ICdub3QtYW4tYXJyYXknXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogaW52YWxpZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZWdpc3Rlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludGVyZXN0cyBtdXN0IGJlIGFuIGFycmF5LidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBnZW5kZXIgaXMgaW52YWxpZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi52YWxpZFJlZ2lzdGVyRGF0YSxcclxuICAgICAgICAgICAgICAgIGdlbmRlcjogJ2ludmFsaWQtZ2VuZGVyJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IGludmFsaWREYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiR2VuZGVyIG11c3QgYmUgZWl0aGVyICdtYWxlJyBvciAnZmVtYWxlJy5cIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIGJpcnRoZGF5IGZvcm1hdCBpcyBpbnZhbGlkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkUmVnaXN0ZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgYmlydGhkYXk6ICdpbnZhbGlkLWRhdGUnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogaW52YWxpZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZWdpc3Rlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgYmlydGhkYXkgZm9ybWF0LidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBpZiBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHJlcXVpcmVtZW50cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi52YWxpZFJlZ2lzdGVyRGF0YSxcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAnd2VhaycsXHJcbiAgICAgICAgICAgICAgICBjb25maXJtUGFzc3dvcmQ6ICd3ZWFrJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IGludmFsaWREYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBsb25nLCBpbmNsdWRlIGFuIHVwcGVyY2FzZSBsZXR0ZXIsIGxvd2VyY2FzZSBsZXR0ZXIsIGEgbnVtYmVyLCBhbmQgYSBzcGVjaWFsIGNoYXJhY3Rlci4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgaWYgZmFtaWx5IG5hbWUgaXMgd3JvbmcgZm9yIGV4aXN0aW5nIGZhbWlseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja0ZhbWlseURhdGEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja0ZhbWlseSh7XHJcbiAgICAgICAgICAgICAgICBlbWFpbDogdmFsaWRSZWdpc3RlckRhdGEuZW1haWwsXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlOYW1lOiAnRGlmZmVyZW50IEZhbWlseSBOYW1lJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW9ja0ZhbWlseS5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tGYW1pbHlEYXRhIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogdmFsaWRSZWdpc3RlckRhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZWdpc3Rlcihtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1dyb25nIGZhbWlseSBuYW1lJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGlmIG1lbWJlciB3aXRoIHNhbWUgbmFtZSBleGlzdHMgaW4gZmFtaWx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrRmFtaWx5RGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrRmFtaWx5KHtcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB2YWxpZFJlZ2lzdGVyRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgIGZhbWlseU5hbWU6IHZhbGlkUmVnaXN0ZXJEYXRhLmZhbWlseU5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWxpZFJlZ2lzdGVyRGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5SWQ6IG1vY2tGYW1pbHlEYXRhLl9pZFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG1vY2tGYW1pbHkuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRmFtaWx5RGF0YSBhcyBhbnkpO1xyXG4gICAgICAgICAgICBtb2NrVXNlci5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nVXNlciBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVxdWVzdCh7IGJvZHk6IHZhbGlkUmVnaXN0ZXJEYXRhIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVzID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXNwb25zZSgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgcmVnaXN0ZXIobW9ja1JlcSBhcyBhbnksIG1vY2tSZXMgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAwKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuanNvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdBIG1lbWJlciB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZmFtaWx5LidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBtb2NrRmFtaWx5LmZpbmRPbmUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZFJlZ2lzdGVyRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHJlZ2lzdGVyKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcmVnaXN0ZXJpbmcuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIFxyXG4gICAgLy8gMy4gdGVzdCBmb3JnZXRQYXNzd29yZCBBUElcclxuICAgIGRlc2NyaWJlKCdmb3JnZXRQYXNzd29yZCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSA9IHtcclxuICAgICAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXHJcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbSdcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHNlbmQgdGVtcG9yYXJ5IHBhc3N3b3JkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhKTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZvcmdldFBhc3N3b3JkKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1VzZXIuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICAgICAgICAgICAgZW1haWw6IHZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhLmVtYWlsLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdmFsaWRGb3JnZXRQYXNzd29yZERhdGEubmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tHZW5lcmF0ZVNlY3VyZVBhc3N3b3JkLmdlbmVyYXRlU2VjdXJlUGFzc3dvcmQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tCY3J5cHQuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1RlbXBQYXNzMTIzIScsIDEyKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5pc1RlbXBQYXNzd29yZCkudG9CZSh0cnVlKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5wYXNzd29yZENoYW5nZWRBdCkudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tFbWFpbFNlcnZpY2Uuc2VuZE1haWwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0d1YXJkaWFuIEdyb3ZlJyksXHJcbiAgICAgICAgICAgICAgICB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgICdZb3VyIFRlbXBvcmFyeSBQYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVGVtcFBhc3MxMjMhJylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyMDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGVtcG9yYXJ5IHBhc3N3b3JkIHNlbnQgdG8geW91ciBlbWFpbC4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiA0MDQgaWYgdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogdmFsaWRGb3JnZXRQYXNzd29yZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBmb3JnZXRQYXNzd29yZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0MDQpO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgY3JlZGVudGlhbHMuIFVzZXIgbm90IGZvdW5kLidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtYWlsIHNlcnZpY2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHRlc3RVdGlscy5jcmVhdGVNb2NrVXNlcih2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcbiAgICAgICAgICAgIG1vY2tFbWFpbFNlcnZpY2Uuc2VuZE1haWwubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFbWFpbCBzZXJ2aWNlIGZhaWxlZCcpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZvcmdldFBhc3N3b3JkKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnRXJyb3Igc2VuZGluZyB0ZW1wb3JhcnkgcGFzc3dvcmQuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2Ugc2F2ZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhKTtcclxuICAgICAgICAgICAgbW9ja1VzZXJEYXRhLnNhdmUgPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBzYXZlIGZhaWxlZCcpKTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZvcmdldFBhc3N3b3JkKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUwMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrUmVzLmpzb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnRXJyb3Igc2VuZGluZyB0ZW1wb3JhcnkgcGFzc3dvcmQuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFzc3dvcmQgaGFzaGluZyBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhKTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuICAgICAgICAgICAgKG1vY2tCY3J5cHQuaGFzaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignSGFzaGluZyBmYWlsZWQnKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogdmFsaWRGb3JnZXRQYXNzd29yZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBmb3JnZXRQYXNzd29yZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tSZXMuc3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1MDApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja1Jlcy5qc29uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0Vycm9yIHNlbmRpbmcgdGVtcG9yYXJ5IHBhc3N3b3JkLidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgcHJvcGVyIGVtYWlsIEhUTUwgY29udGVudCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHtcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvaG4gRG9lJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW9ja1VzZXIuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlckRhdGEgYXMgYW55KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXEgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1JlcXVlc3QoeyBib2R5OiB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSB9KTtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1JlcyA9IHRlc3RVdGlscy5jcmVhdGVNb2NrUmVzcG9uc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZvcmdldFBhc3N3b3JkKG1vY2tSZXEgYXMgYW55LCBtb2NrUmVzIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QobW9ja0VtYWlsU2VydmljZS5zZW5kTWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXHJcbiAgICAgICAgICAgICAgICB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgICdZb3VyIFRlbXBvcmFyeSBQYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL0hlbGxvIEpvaG4gRG9lLylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tFbWFpbFNlcnZpY2Uuc2VuZE1haWwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRGb3JnZXRQYXNzd29yZERhdGEuZW1haWwsXHJcbiAgICAgICAgICAgICAgICAnWW91ciBUZW1wb3JhcnkgUGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9UZW1wUGFzczEyMyEvKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QobW9ja0VtYWlsU2VydmljZS5zZW5kTWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXHJcbiAgICAgICAgICAgICAgICB2YWxpZEZvcmdldFBhc3N3b3JkRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgICdZb3VyIFRlbXBvcmFyeSBQYXNzd29yZCcsXHJcbiAgICAgICAgICAgICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL0d1YXJkaWFuIEdyb3ZlIFRlYW0vKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIHNldCBjb3JyZWN0IHVzZXIgcHJvcGVydGllcyBhZnRlciBwYXNzd29yZCByZXNldCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9ja1VzZXJEYXRhID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tVc2VyKHtcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkRm9yZ2V0UGFzc3dvcmREYXRhLFxyXG4gICAgICAgICAgICAgICAgaXNUZW1wUGFzc3dvcmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFuZ2VkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAxJylcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vY2tVc2VyLmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXJEYXRhIGFzIGFueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2NrUmVxID0gdGVzdFV0aWxzLmNyZWF0ZU1vY2tSZXF1ZXN0KHsgYm9keTogdmFsaWRGb3JnZXRQYXNzd29yZERhdGEgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZXMgPSB0ZXN0VXRpbHMuY3JlYXRlTW9ja1Jlc3BvbnNlKCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBmb3JnZXRQYXNzd29yZChtb2NrUmVxIGFzIGFueSwgbW9ja1JlcyBhcyBhbnkpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5wYXNzd29yZCkudG9CZSgnaGFzaGVkUGFzc3dvcmQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5pc1RlbXBQYXNzd29yZCkudG9CZSh0cnVlKTtcclxuICAgICAgICAgICAgZXhwZWN0KG1vY2tVc2VyRGF0YS5wYXNzd29yZENoYW5nZWRBdCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVXNlckRhdGEuc2F2ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tVc2VyIiwiVXNlciIsIm1vY2tGYW1pbHkiLCJGYW1pbHkiLCJtb2NrR2VuZXJhdGVTZWN1cmVQYXNzd29yZCIsImdlbmVyYXRlU2VjdXJlUGFzc3dvcmQiLCJtb2NrRW1haWxTZXJ2aWNlIiwiZW1haWxTZXJ2aWNlIiwibW9ja0JjcnlwdCIsImJjcnlwdCIsIm1vY2tKd3QiLCJqd3QiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiZmluZE9uZSIsImZuIiwiY3JlYXRlIiwibW9ja1JldHVyblZhbHVlIiwic3B5T24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVuZGVmaW5lZCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiYWZ0ZXJFYWNoIiwidmFsaWRMb2dpbkRhdGEiLCJuYW1lIiwiZW1haWwiLCJwYXNzd29yZCIsIml0IiwibW9ja1VzZXJEYXRhIiwidGVzdFV0aWxzIiwiY3JlYXRlTW9ja1VzZXIiLCJpc1RlbXBQYXNzd29yZCIsImlkIiwiY29tcGFyZSIsIm1vY2tSZXEiLCJjcmVhdGVNb2NrUmVxdWVzdCIsImJvZHkiLCJtb2NrUmVzIiwiY3JlYXRlTW9ja1Jlc3BvbnNlIiwibG9naW4iLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInNpZ24iLCJ1c2VySWQiLCJyb2xlIiwic3RhdHVzIiwianNvbiIsInVzZXIiLCJ0b2tlbiIsInJlcXVpcmVzUGFzc3dvcmRDaGFuZ2UiLCJtZXNzYWdlIiwiaW5jb21wbGV0ZURhdGEiLCJlcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJ2YWxpZFJlZ2lzdGVyRGF0YSIsImNvbmZpcm1QYXNzd29yZCIsImJpcnRoZGF5IiwiZ2VuZGVyIiwiYXZhdGFyIiwiaW50ZXJlc3RzIiwiZmFtaWx5TmFtZSIsImZhbWlseUF2YXRhciIsIm1vY2tGYW1pbHlEYXRhIiwiY3JlYXRlTW9ja0ZhbWlseSIsIm1lbWJlcnMiLCJtb2NrQ3JlYXRlZFVzZXIiLCJmYW1pbHlJZCIsIl9pZCIsInByb3RvdHlwZSIsInNhdmUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWdpc3RlciIsImhhc2giLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiaW52YWxpZERhdGEiLCJleGlzdGluZ1VzZXIiLCJ2YWxpZEZvcmdldFBhc3N3b3JkRGF0YSIsImZvcmdldFBhc3N3b3JkIiwidG9CZSIsInBhc3N3b3JkQ2hhbmdlZEF0IiwidG9CZURlZmluZWQiLCJzZW5kTWFpbCIsInN0cmluZ0NvbnRhaW5pbmciLCJzZW5kIiwiYW55IiwiU3RyaW5nIiwic3RyaW5nTWF0Y2hpbmciLCJEYXRlIiwidG9CZUluc3RhbmNlT2YiXSwibWFwcGluZ3MiOiI7QUFTQSx3QkFBd0I7QUFDeEJBLEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDOzs7O3VCQWZnQjtnQ0FDc0I7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